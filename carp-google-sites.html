<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>carp.edu</title>
  <style>
:root{
  --bg-1: #071226;
  --bg-2: #042033;
  --card: #071b2a;
  --accent: #39c5ff;
  --muted: #9fb6c6;
  --glass: rgba(255,255,255,0.03);
  --radius: 12px;
  --tile-h: 180px;
  --gap: 14px;
  --ui-font: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
html{
  height:100%;
}

body{
  margin:0;
}

*, *::before, *::after{
  box-sizing:border-box;
}

body.page-carpfish{
  min-height:100%;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6eef8;
  -webkit-font-smoothing:antialiased;
}

body.page-carpfish .container{max-width:1140px;margin:18px auto;padding:18px}
body.page-carpfish header{display:flex;align-items:center;justify-content:space-between;gap:12px}
body.page-carpfish h1{margin:0;font-size:20px;font-weight:800;letter-spacing:-0.2px}
body.page-carpfish .subtitle{color:var(--muted);font-size:13px}
body.page-carpfish .controls{display:flex;gap:8px;align-items:center}
body.page-carpfish .btn{background:var(--accent);color:#04202b;border:0;padding:8px 12px;border-radius:10px;font-weight:800;cursor:pointer}
body.page-carpfish .small{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:9px;cursor:pointer}

body.page-carpfish .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:var(--gap);margin-top:18px}
body.page-carpfish .tile{
  background:linear-gradient(180deg,var(--glass), transparent);
  border-radius:var(--radius);padding:14px;min-height:var(--tile-h);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.6);transition:transform .12s ease, box-shadow .12s ease;
  text-align:center;
}
body.page-carpfish .tile:hover{transform:translateY(-6px);box-shadow:0 18px 40px rgba(0,0,0,0.6)}
body.page-carpfish .tile-empty{pointer-events:none;cursor:default}
body.page-carpfish .tile .title{font-weight:900;margin-bottom:6px}
body.page-carpfish .tile .desc{color:var(--muted);font-size:13px}

body.page-carpfish main#mainArea{margin-top:22px}
body.page-carpfish .listView .muted{color:var(--muted);margin-top:8px;text-align:center}

body.page-carpfish .game-area{background:linear-gradient(180deg,#081827,#06151f);padding:14px;border-radius:12px;color:#fff;min-height:360px}
body.page-carpfish .backbar{display:flex;gap:8px;align-items:center;margin-bottom:12px}
body.page-carpfish .game-header{display:flex;align-items:center;gap:12px}
body.page-carpfish .game-title{font-weight:900}
body.page-carpfish .score-pill{background:#062f39;color:#bff0ff;padding:6px 10px;border-radius:8px;font-weight:800}
body.page-carpfish .game-root{min-height:320px;position:relative}
body.page-carpfish .drive-wrapper{display:flex;flex-direction:column;gap:12px;align-items:center}
body.page-carpfish .drive-frame{width:100%;min-height:420px;border:0;border-radius:16px;box-shadow:0 16px 36px rgba(0,0,0,0.45);background:#000}
body.page-carpfish .drive-help{color:var(--muted);font-size:13px;text-align:center;max-width:540px}
body.page-carpfish .basket-wrapper{display:flex;flex-direction:column;gap:12px;align-items:center}
body.page-carpfish .basket-frame{width:100%;min-height:520px;border:0;border-radius:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);background:#000}
body.page-carpfish .basket-help{color:var(--muted);font-size:13px;text-align:center;max-width:640px}
body.page-carpfish .ancient-wrapper{display:flex;flex-direction:column;gap:12px;align-items:center}
body.page-carpfish .ancient-frame{width:100%;min-height:520px;border:0;border-radius:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);background:#000}
body.page-carpfish .ancient-help{color:var(--muted);font-size:13px;text-align:center;max-width:640px}
body.page-carpfish .game-over{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  background:rgba(0,0,0,0.9);
  color:#fff;
  padding:20px 30px;
  border-radius:12px;
  text-align:center;
  animation:fadeIn 0.3s ease;
  z-index:100;
}
body.page-carpfish .game-over .score{
  font-size:24px;
  font-weight:800;
  margin:10px 0;
  color:var(--accent);
}
body.page-carpfish .game-over .retry{
  background:var(--accent);
  color:#042033;
  border:0;
  padding:8px 16px;
  border-radius:8px;
  font-weight:800;
  margin-top:10px;
  cursor:pointer;
}
@keyframes fadeIn {
  from { opacity:0; transform:translate(-50%, -60%); }
  to { opacity:1; transform:translate(-50%, -50%); }
}

/* 2048 styles */
body.page-carpfish .g2048-board{
  background:#bbada0;padding:12px;border-radius:8px;
  display:grid;grid-template-columns:repeat(4,1fr);gap:12px;
  max-width:520px;margin:0 auto;
  perspective:1000px;
}
body.page-carpfish .g2048-cell{
  height:82px;border-radius:6px;background:#cdc1b4;
  display:flex;align-items:center;justify-content:center;
  font-weight:900;font-size:22px;color:#776e65;
  transition:all .3s ease;
  box-shadow:0 4px 8px rgba(0,0,0,0.1);
  position:relative;
}
body.page-carpfish .g2048-cell.new{
  animation:pop3d .4s cubic-bezier(.17,.67,.21,1.69) forwards;
}
@keyframes pop3d{
  0%{transform:scale(0.85) translateY(-10px)}
  100%{transform:scale(1) translateY(0)}
}
body.page-carpfish .g2048-cell:hover{
  transform:translateY(-4px);
  box-shadow:0 8px 16px rgba(0,0,0,0.15);
}

/* Memory flip */
body.page-carpfish .mem-grid{
  display:grid;grid-template-columns:repeat(6,1fr);gap:8px;
  max-width:680px;margin:0 auto;
  perspective:2000px;
  transform-style:preserve-3d;
}
body.page-carpfish .mem-card{
  height:78px;border-radius:10px;overflow:hidden;
  border:0;background:transparent;perspective:1200px;
  transform-style:preserve-3d;
  transition:transform .3s ease;
}
body.page-carpfish .mem-card:hover{
  transform:translateZ(20px) scale(1.05);
}

body.page-carpfish .mem-inner{
  position:relative;width:100%;height:100%;
  transform-style:preserve-3d;
  transition:transform .5s ease;
}
body.page-carpfish .mem-inner.revealed{
  transform:rotateY(180deg);
}
body.page-carpfish .mem-front, body.page-carpfish .mem-back{
  position:absolute;top:0;left:0;width:100%;height:100%;
  backface-visibility:hidden;border-radius:10px;
  display:flex;align-items:center;justify-content:center;
  font-size:26px;font-weight:700;
}
body.page-carpfish .mem-front{background:linear-gradient(135deg,#123,#234);color:#fff}
body.page-carpfish .mem-back{background:#0ea5ff;color:#021026;transform:rotateY(180deg)}

body.page-carpfish .whack-grid{
  display:grid;grid-template-columns:repeat(3,1fr);gap:12px;
  max-width:520px;margin:0 auto;
}
body.page-carpfish .whack-hole{
  height:120px;border-radius:10px;background:radial-gradient(circle at center,#1b3342,#071b2a);
  display:flex;align-items:center;justify-content:center;
  position:relative;overflow:hidden;
}
body.page-carpfish .whack-mole{
  width:70px;height:70px;border-radius:50%;
  background:radial-gradient(circle at 30% 30%,#ffd27f,#d1903b);
  position:absolute;bottom:-70px;transition:bottom 0.2s ease;
  box-shadow:0 8px 18px rgba(0,0,0,0.6);
}
body.page-carpfish .whack-mole.up{bottom:20px}

body.page-carpfish .card-list{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
body.page-carpfish .card{background:#071b2a;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:10px;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
body.page-carpfish .card .title{font-weight:900;font-size:18px}
body.page-carpfish .card .copy{color:#9fb6c6;font-size:13px;line-height:1.5}

body.page-carpfish .snake-grid{display:grid;grid-template-columns:repeat(20,1fr);gap:3px;max-width:420px;margin:0 auto}
body.page-carpfish .snake-cell{width:18px;height:18px;border-radius:4px;background:#06121f}

body.page-carpfish .pong-table{position:relative;width:100%;max-width:640px;height:380px;margin:0 auto;background:#06121f;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.05);box-shadow:inset 0 0 40px rgba(0,0,0,0.6)}
body.page-carpfish .pong-paddle{position:absolute;width:12px;height:70px;background:linear-gradient(180deg,#39c5ff,#0582ca);border-radius:6px}
body.page-carpfish .pong-ball{position:absolute;width:16px;height:16px;border-radius:50%;background:#fff;box-shadow:0 0 20px rgba(57,197,255,0.5)}

body.page-carpfish .tower-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:10px;max-width:600px;margin:0 auto}
body.page-carpfish .tower-cell{height:80px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}

body.page-carpfish .inv-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-top:12px}
body.page-carpfish .inv-item{height:60px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:28px}

body.page-carpfish .maze-game{background:#06121f;border-radius:12px;position:relative;overflow:hidden}
body.page-carpfish .maze-player{position:absolute;width:24px;height:24px;border-radius:6px;background:#39c5ff;box-shadow:0 0 12px rgba(57,197,255,0.6)}
body.page-carpfish .maze-exit{position:absolute;width:40px;height:40px;border-radius:50%;background:#8bc34a;box-shadow:0 0 16px rgba(139,195,74,0.5)}

body.page-carpfish .chess-board{display:grid;grid-template-columns:repeat(8,1fr);width:320px;height:320px;border-radius:10px;overflow:hidden;box-shadow:0 6px 20px rgba(0,0,0,0.4);margin:0 auto}
body.page-carpfish .chess-square{display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:700}
body.page-carpfish .chess-square.light{background:#f0d9b5;color:#4e342e}
body.page-carpfish .chess-square.dark{background:#b58863;color:#fff}

body.page-carpfish .doodle-platform{position:absolute;width:80px;height:16px;background:#3cb371;border-radius:8px}
body.page-carpfish .doodle-player{position:absolute;width:40px;height:40px;background:#ffeb3b;border-radius:50%;box-shadow:0 0 16px rgba(255,235,59,0.6)}

body.page-carpfish .racer-road{position:relative;width:100%;max-width:600px;height:400px;margin:0 auto;border-radius:16px;background:#101820;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
body.page-carpfish .road-line{position:absolute;left:50%;width:6px;height:40px;margin-left:-3px;background:rgba(255,255,255,0.4);border-radius:4px}
body.page-carpfish .racer-car{position:absolute;width:50px;height:90px;border-radius:12px;background:linear-gradient(180deg,#ff5722,#d84315);box-shadow:0 8px 20px rgba(0,0,0,0.5)}

body.page-carpfish .fruit-canvas{background:#061827;border-radius:12px;width:100%;max-width:640px;height:400px;margin:0 auto;box-shadow:0 10px 26px rgba(0,0,0,0.5)}

body.page-carpfish .tower-path{stroke:#39c5ff;stroke-width:4;fill:none;stroke-dasharray:6 6;animation:pathGlow 2s linear infinite;filter:drop-shadow(0 0 6px rgba(57,197,255,0.6))}
@keyframes pathGlow{
  0%{stroke-dashoffset:0}
  100%{stroke-dashoffset:-12}
}

body.page-account,
body.page-home{
  height:100%;
  overflow:hidden;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  background:
    radial-gradient(circle at 15% 20%, rgba(56,189,248,0.22), transparent 55%),
    radial-gradient(circle at 80% 0%, rgba(139,92,246,0.18), transparent 55%),
    radial-gradient(circle at 20% 80%, rgba(16,185,129,0.18), transparent 60%),
    #020617;
  color:#e6f1ff;
}

body.page-home .page{height:100vh;display:flex;flex-direction:column}
body.page-home .topbar{flex:0 0 48px;display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 12px;
  background:rgba(8,20,39,0.78);box-shadow:0 2px 12px rgba(3,7,18,0.5);border:1px solid rgba(148,191,224,0.15);border-radius:14px;margin:12px}
body.page-home .topbar-left, body.page-home .topbar-right {
  display:flex;align-items:center;gap:8px;
}
body.page-home .top-btn{
  background:rgba(14,165,233,0.16);color:#d3ecff;border:1px solid rgba(148,191,224,0.25);padding:6px 14px;border-radius:999px;
  font-weight:700;font-size:13px;text-decoration:none;cursor:pointer;display:inline-flex;align-items:center;gap:6px;
}
body.page-home .top-btn:hover{background:rgba(14,165,233,0.28);color:#f4fbff;border-color:rgba(148,191,224,0.45)}
body.page-home .top-btn.accent{background:linear-gradient(135deg,#0ea5ff,#38bdf8);color:#03121f;border:0}
body.page-home .top-btn.accent:hover{background:linear-gradient(135deg,#38bdf8,#0ea5ff)}

body.page-home .big-banner{
  flex:1;
  display:flex;flex-direction:column;
  border-bottom:6px solid rgba(148,191,224,0.12);
  background:linear-gradient(140deg,#0ea5ff,#6366f1);
  color:#021026;
  border-radius:28px;
  margin:12px;
  box-shadow:0 24px 50px rgba(3,7,18,0.45);
  position:relative;
}
body.page-home .big-top, body.page-home .big-bottom{
  flex:1;display:flex;align-items:center;justify-content:center;text-align:center;
  padding:12px;
}
body.page-home .big-top{font-weight:900;font-size:clamp(20px,5vw,56px);color:#07121f;background:linear-gradient(180deg,rgba(255,255,255,0.35),transparent);}
body.page-home .big-bottom{font-weight:800;font-size:clamp(20px,4.2vw,48px);color:#f4fbff;background:linear-gradient(180deg,rgba(5,11,25,0.28),transparent)}

body.page-home .bottom-row{
  flex:0 0 40vh;
  display:flex;gap:12px;padding:12px;
  background:linear-gradient(180deg,rgba(2,6,23,0.85),rgba(4,20,39,0.92));
  box-sizing:border-box;
  border-radius:20px;
  margin:0 12px 12px;
  border:1px solid rgba(148,191,224,0.12);
  box-shadow:0 18px 40px rgba(3,7,18,0.45);
}
body.page-home .small-banner{
  flex:1;display:flex;align-items:center;justify-content:center;
  border-radius:16px;background:linear-gradient(135deg,#0f172a,#1e293b);
  color:#eaf4ff;font-weight:800;font-size:clamp(12px,2.4vw,20px);
  box-shadow:0 16px 36px rgba(3,7,18,0.5);
  border:1px solid rgba(148,191,224,0.16);
  text-decoration:none;
  text-transform:uppercase;
  letter-spacing:1.5px;
  transition:transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}
body.page-home .small-banner:hover{
  transform:translateY(-4px);
  box-shadow:0 26px 52px rgba(3,7,18,0.55);
  border-color:rgba(148,191,224,0.32);
}

@media (max-height:420px){
  body.page-home .bottom-row{flex-basis:45vh;padding:8px;gap:8px}
  body.page-home .small-banner{font-size:12px}
}

/* Account page */
body.page-account{
  --accent:#2f9e44;
  background:radial-gradient(circle at 15% 20%,rgba(47,158,68,0.2),transparent 50%),radial-gradient(circle at 85% 40%,rgba(32,131,207,0.18),transparent 55%),#04111d;
  min-height:100vh;
  color:#d8e2ec;
  font-family:"Segoe UI",sans-serif;
  padding:40px 20px;
  box-sizing:border-box;
}
body.page-account .account-shell{
  max-width:960px;
  margin:0 auto;
  display:flex;
  flex-direction:column;
  gap:24px;
}
body.page-account .account-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
}
body.page-account .account-tabs{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  padding:12px;
  border-radius:14px;
  background:rgba(6,28,42,0.8);
  box-shadow:inset 0 0 0 1px rgba(148,191,224,0.1);
}
body.page-account .tab-link{
  background:transparent;
  color:#9fbad4;
  border:1px solid rgba(148,191,224,0.25);
  border-radius:999px;
  padding:8px 20px;
  font-size:14px;
  font-weight:600;
  cursor:pointer;
  transition:all 0.2s ease;
}
body.page-account .tab-link:is(:hover,:focus-visible){
  color:#d8e2ec;
  border-color:rgba(47,158,68,0.55);
  box-shadow:0 0 0 2px rgba(47,158,68,0.15);
  outline:none;
}
body.page-account .tab-link.is-active{
  background:rgba(47,158,68,0.25);
  color:#eef8ff;
  border-color:rgba(47,158,68,0.65);
  box-shadow:0 0 0 2px rgba(47,158,68,0.25);
}
body.page-account .account-main{
  display:block;
}
body.page-account .tab-panel{
  margin-top:24px;
}
body.page-account .card{
  background:rgba(4,25,40,0.92);
  border-radius:16px;
  padding:24px;
  box-shadow:0 18px 32px rgba(0,0,0,0.35);
  backdrop-filter:blur(10px);
  display:flex;
  flex-direction:column;
  gap:16px;
}
body.page-account .account-form-card h1{
  margin:0;
  font-size:24px;
  font-weight:800;
  letter-spacing:0.5px;
}
body.page-account .account-subtext{
  margin:0;
  color:#92adc6;
  font-size:14px;
}
body.page-account .field-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
  gap:12px;
}
body.page-account .field{
  display:flex;
  flex-direction:column;
  gap:6px;
  font-size:13px;
  color:#adc6da;
}
body.page-account .field input,
body.page-account .field textarea{
  background:rgba(8,32,45,0.9);
  border:1px solid rgba(147,191,224,0.25);
  border-radius:10px;
  padding:10px 12px;
  color:#f2f7fb;
  font-size:15px;
  resize:vertical;
}
body.page-account .field input:focus,
body.page-account .field textarea:focus{
  border-color:rgba(47,158,68,0.6);
  outline:none;
  box-shadow:0 0 0 2px rgba(47,158,68,0.2);
}
body.page-account .btn{
  border:0;
  border-radius:12px;
  font-weight:600;
  cursor:pointer;
  transition:transform .15s ease,box-shadow .15s ease,opacity .15s ease;
}
body.page-account .btn.primary{
  background:linear-gradient(120deg,#2f9e44,#3bc9db);
  color:#031018;
  padding:10px 20px;
  box-shadow:0 10px 20px rgba(59,201,219,0.25);
}
body.page-account .btn.primary:hover{
  transform:translateY(-1px);
  box-shadow:0 14px 24px rgba(59,201,219,0.35);
}
body.page-account .btn.subtle{
  background:rgba(255,255,255,0.04);
  color:#a8c2da;
  padding:8px 16px;
  border:1px solid rgba(255,255,255,0.08);
}
body.page-account .btn.subtle[disabled]{
  opacity:0.4;
  cursor:not-allowed;
}
body.page-account .btn.tiny{
  padding:6px 10px;
  background:rgba(255,255,255,0.05);
  color:#d6e2ef;
  border:1px solid rgba(255,255,255,0.08);
}
body.page-account .btn.tiny:hover{
  transform:translateY(-1px);
}
body.page-account .btn.tiny.danger{
  color:#ff9797;
  border-color:rgba(255,151,151,0.35);
}
body.page-account .account-status{
  min-height:20px;
  font-size:13px;
  color:#7dd3a7;
}
body.page-account .account-status.error{
  color:#ff8787;
}
body.page-account .posts-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
}
body.page-account .post-form{
  display:flex;
  flex-direction:column;
  gap:12px;
}
body.page-account .post-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-account .post-item{
  background:rgba(7,25,40,0.88);
  border-radius:12px;
  padding:14px;
  border:1px solid rgba(255,255,255,0.04);
  display:flex;
  flex-direction:column;
  gap:10px;
}
body.page-account .post-meta{
  font-size:12px;
  color:#82a5c4;
  letter-spacing:0.5px;
  text-transform:uppercase;
}
body.page-account .post-body{
  margin:0;
  font-size:15px;
  line-height:1.5;
  color:#f3f7fb;
}
body.page-account .post-actions{
  display:flex;
  gap:8px;
}
body.page-account .hint{
  margin:0;
  font-size:13px;
  color:#7f9bb4;
}
body.page-account .account-db-card{
  display:flex;
  flex-direction:column;
  gap:16px;
}
body.page-account .account-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:12px;
}
body.page-account .account-entry{
  display:flex;
  align-items:center;
  gap:12px;
  padding:10px 12px;
  border-radius:12px;
  background:rgba(8,25,46,0.65);
  border:1px solid rgba(148,191,224,0.12);
}
body.page-account .account-entry-avatar{
  width:46px;
  height:46px;
  border-radius:50%;
  object-fit:cover;
  border:2px solid rgba(148,191,224,0.25);
}
body.page-account .account-entry-avatar.placeholder{
  background:rgba(15,35,54,0.8);
}
body.page-account .account-entry-body{
  display:flex;
  flex-direction:column;
  gap:4px;
}
body.page-account .account-entry-name{
  font-weight:700;
  font-size:15px;
  color:#ecf4ff;
}
body.page-account .account-entry-meta{
  font-size:13px;
  color:#9fb6c6;
}
body.page-account .profile-preview{
  display:flex;
  align-items:center;
  gap:14px;
  margin-top:18px;
  padding:12px 16px;
  border-radius:14px;
  background:rgba(8,25,46,0.85);
  border:1px solid rgba(148,191,224,0.18);
}
body.page-account .profile-preview img{
  width:60px;
  height:60px;
  border-radius:50%;
  object-fit:cover;
  border:2px solid rgba(148,191,224,0.35);
}
body.page-account .profile-preview-info{
  display:flex;
  flex-direction:column;
  gap:4px;
}
body.page-account .profile-preview-info #profileName{
  font-weight:700;
  font-size:15px;
  color:#f2f7ff;
}
body.page-account .profile-preview-info #profileEmail{
  font-size:13px;
  color:#9fb6c6;
}

/* Social feed page */
body.page-social{
  min-height:100vh;
  margin:0;
  font-family:"Segoe UI",sans-serif;
  background:radial-gradient(circle at 12% 18%,rgba(14,116,144,0.32),transparent 54%),radial-gradient(circle at 82% -10%,rgba(113,59,185,0.28),transparent 60%),#050c16;
  color:#e6eef8;
  padding:32px 20px 64px;
  box-sizing:border-box;
  display:flex;
  flex-direction:column;
  gap:24px;
}
body.page-social .social-topbar{
  position:sticky;
  top:0;
  left:0;
  right:0;
  z-index:50;
  margin:0 auto;
  padding:16px 24px;
  width:min(1180px,100%);
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:18px;
  background:rgba(6,24,40,0.92);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  box-shadow:0 24px 48px rgba(5,11,23,0.45);
  backdrop-filter:blur(14px);
}
body.page-social .brand{
  display:flex;
  gap:14px;
  align-items:flex-start;
}
body.page-social .logo-dot{
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(135deg,#0ea5ff,#38bdf8);
  box-shadow:0 0 14px rgba(14,165,233,0.9);
  margin-top:4px;
}
body.page-social .titles h1{
  margin:0;
  font-size:28px;
  letter-spacing:0.8px;
}
body.page-social .titles .tagline{
  margin:6px 0 0;
  color:#9fb6c6;
  font-size:13px;
}
body.page-social .top-actions{
  display:flex;
  gap:16px;
  align-items:center;
  flex-wrap:wrap;
  justify-content:flex-end;
}
body.page-social nav{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
body.page-social .chip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 16px;
  border-radius:999px;
  background:rgba(255,255,255,0.08);
  color:#e6f4ff;
  font-size:13px;
  font-weight:600;
  text-decoration:none;
  border:0;
  cursor:pointer;
  transition:transform .12s ease,background .12s ease,box-shadow .12s ease;
}
body.page-social .chip:hover{
  background:rgba(255,255,255,0.16);
  transform:translateY(-1px);
}
body.page-social .chip.action{
  background:linear-gradient(135deg,#0ea5ff,#38bdf8);
  color:#031321;
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:0.6px;
  box-shadow:0 12px 24px rgba(14,165,233,0.28);
}
body.page-social .chip.action:hover{
  box-shadow:0 16px 32px rgba(14,165,233,0.35);
}
body.page-social .social-layout{
  width:min(1180px,100%);
  margin:0 auto;
  display:grid;
  grid-template-columns:260px minmax(0,1fr) 260px;
  gap:20px;
  align-items:start;
}
body.page-social .social-sidebar,
body.page-social .social-right{
  display:flex;
  flex-direction:column;
  gap:20px;
}
body.page-social .card{
  background:rgba(7,26,42,0.9);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  box-shadow:0 24px 46px rgba(5,12,20,0.45);
  padding:22px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-social .card h2,
body.page-social .card h3{
  margin:0;
  font-size:18px;
  font-weight:800;
}
body.page-social .card p,
body.page-social .card li{
  font-size:13px;
  color:#9fb6c6;
  line-height:1.5;
}
body.page-social .card ul{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:10px;
}
body.page-social .quick-stats ul li{
  display:flex;
  justify-content:space-between;
  align-items:center;
  background:rgba(255,255,255,0.04);
  border-radius:12px;
  padding:10px 12px;
}
body.page-social .quick-stats .stat-label{
  color:#9fb6c6;
  font-size:13px;
}
body.page-social .quick-stats .stat-value{
  font-size:16px;
  font-weight:800;
  color:#e8f6ff;
}
body.page-social .composer-card{
  gap:18px;
}
body.page-social .composer-card header h2{
  font-size:22px;
}
body.page-social .hint{
  margin:4px 0 0;
  color:#8fa6bc;
  font-size:13px;
}
body.page-social .composer-form{
  display:flex;
  flex-direction:column;
  gap:16px;
}
body.page-social .field{
  display:flex;
  flex-direction:column;
  gap:6px;
  font-size:13px;
  color:#a3bfdc;
}
body.page-social .field textarea,
body.page-social .field input{
  background:rgba(9,32,49,0.92);
  border:1px solid rgba(148,187,233,0.24);
  border-radius:12px;
  padding:10px 12px;
  color:#f1f6fc;
  font-size:15px;
  font-family:inherit;
  resize:vertical;
}
body.page-social .field textarea:focus,
body.page-social .field input:focus{
  border-color:rgba(14,165,233,0.6);
  outline:none;
  box-shadow:0 0 0 2px rgba(14,165,233,0.22);
}
body.page-social .upload-block{
  border:1px dashed rgba(148,191,224,0.28);
  border-radius:16px;
  padding:18px;
  background:rgba(7,26,42,0.6);
}
body.page-social .upload-actions{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
body.page-social .upload-actions .muted{
  color:#8fa6bc;
  font-size:13px;
}
body.page-social .upload{
  position:relative;
}
body.page-social .upload-block input[type="file"]{
  position:absolute;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  border:0;
  clip:rect(0,0,0,0);
  overflow:hidden;
}
body.page-social .media-preview{
  display:flex;
  align-items:center;
  gap:12px;
  padding:12px 14px;
  background:rgba(9,32,49,0.75);
  border:1px solid rgba(148,191,224,0.2);
  border-radius:14px;
}
body.page-social .media-preview.hidden{
  display:none;
}
body.page-social .media-preview .thumb{
  width:56px;
  height:56px;
  border-radius:12px;
  background:rgba(148,191,224,0.15);
  background-size:cover;
  background-position:center;
  position:relative;
}
body.page-social .media-preview .thumb.video::after{
  content:"â–¶";
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  color:#0ea5ff;
  font-size:20px;
}
body.page-social .composer-actions{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
}
body.page-social .status{
  min-height:20px;
  font-size:13px;
  color:#7ad7ff;
}
body.page-social .status.error{
  color:#ff9aa5;
}
body.page-social .btn{
  border-radius:12px;
  font-weight:600;
  cursor:pointer;
  transition:transform .12s ease,box-shadow .12s ease,opacity .12s ease;
  border:0;
}
body.page-social .btn.primary{
  background:linear-gradient(135deg,#0ea5ff,#38bdf8);
  color:#031321;
  padding:10px 20px;
  box-shadow:0 16px 32px rgba(14,165,233,0.28);
}
body.page-social .btn.accent{
  background:linear-gradient(135deg,#fbbc04,#f97316);
  color:#031321;
  font-weight:700;
  padding:10px 18px;
  box-shadow:0 18px 36px rgba(249,115,22,0.3);
}
body.page-social .btn.accent:hover{
  transform:translateY(-1px);
  box-shadow:0 22px 42px rgba(249,115,22,0.38);
}
body.page-social .btn.primary:hover{
  transform:translateY(-1px);
  box-shadow:0 20px 36px rgba(14,165,233,0.32);
}
body.page-social .btn.secondary{
  background:rgba(255,255,255,0.08);
  color:#e8f4ff;
  padding:9px 16px;
  border:1px solid rgba(255,255,255,0.12);
}
body.page-social .btn.tiny{
  background:rgba(255,255,255,0.08);
  color:#e6f3ff;
  padding:6px 12px;
  border:1px solid rgba(255,255,255,0.12);
  font-size:12px;
}
body.page-social .btn.tiny.fullscreen-btn{
  background:rgba(14,165,233,0.18);
  color:#061622;
  border:1px solid rgba(14,165,233,0.4);
  font-weight:700;
}
body.page-social .btn.tiny.fullscreen-btn:hover{
  background:rgba(14,165,233,0.28);
  box-shadow:0 12px 24px rgba(14,165,233,0.25);
}
body.page-social .btn.tiny.ghost{
  background:transparent;
  border:1px solid rgba(148,191,224,0.32);
  color:#9fc9eb;
}
body.page-social .social-feed{
  display:flex;
  flex-direction:column;
  gap:32px;
}
body.page-social .feed-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:32px;
}
body.page-social .empty-hint{
  text-align:center;
  font-size:14px;
  color:#8fa6bc;
}

/* CarpStream viewer rebuild */
body.page-social{
  min-height:100vh;
  margin:0;
  font-family:var(--ui-font);
  background:radial-gradient(circle at 12% 18%,rgba(14,116,144,0.25),transparent 50%),radial-gradient(circle at 82% -10%,rgba(113,59,185,0.22),transparent 60%),#050c16;
  color:#e6f4ff;
  padding:24px 16px 48px;
  box-sizing:border-box;
  display:flex;
  flex-direction:column;
  gap:24px;
}
body.page-social .stream-topbar{
  width:min(1240px,100%);
  margin:0 auto;
  background:rgba(7,26,42,0.92);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  padding:18px 24px;
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:20px;
  box-shadow:0 26px 54px rgba(5,12,23,0.45);
  backdrop-filter:blur(14px);
}
body.page-social .stream-topbar .brand{
  display:flex;
  gap:14px;
  align-items:flex-start;
}
body.page-social .stream-topbar h1{
  margin:0;
  font-size:30px;
  letter-spacing:-0.2px;
}
body.page-social .stream-topbar .tagline{
  margin:6px 0 0;
  color:#9fb6c6;
  font-size:13px;
}
body.page-social .stream-topbar .top-actions{
  display:flex;
  flex-direction:column;
  gap:12px;
  align-items:flex-end;
}
body.page-social .stream-topbar nav{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}
body.page-social .stream-topbar .btn.primary{
  padding:10px 20px;
}
body.page-social .stream-main{
  width:min(1240px,100%);
  margin:0 auto;
  display:grid;
  grid-template-columns:minmax(0,1fr) 320px;
  gap:20px;
  align-items:start;
}
body.page-social .viewer{
  background:rgba(7,26,42,0.9);
  border-radius:24px;
  border:1px solid rgba(148,191,224,0.16);
  padding:24px;
  display:flex;
  flex-direction:column;
  gap:22px;
  box-shadow:0 32px 60px rgba(5,12,23,0.4);
}
body.page-social .viewer-media{
  position:relative;
  width:100%;
  min-height:280px;
  background:rgba(5,14,23,0.6);
  border-radius:18px;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
}
body.page-social .viewer-media::before{
  content:"";
  display:block;
  padding-top:56.25%;
}
body.page-social .viewer-media video,
body.page-social .viewer-media img,
body.page-social .viewer-media iframe{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  border:0;
  object-fit:contain;
  background:#000;
}
body.page-social .viewer-empty{
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-size:16px;
  color:#9fb6c6;
  text-align:center;
  padding:0 24px;
}
body.page-social .viewer-panel{
  display:flex;
  flex-direction:column;
  gap:16px;
}
body.page-social .viewer-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:16px;
}
body.page-social .viewer-meta{
  display:flex;
  flex-direction:column;
  gap:4px;
}
body.page-social .viewer-author{
  font-weight:700;
  font-size:16px;
  color:#e6f4ff;
}
body.page-social .viewer-header time{
  font-size:12px;
  color:#8fa6bc;
}
body.page-social .viewer-caption{
  margin:0;
  font-size:17px;
  line-height:1.6;
  color:#e9f4ff;
}
body.page-social .viewer-actions{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
}
body.page-social .viewer-actions .action-btn{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:10px 14px;
  border-radius:999px;
  background:rgba(255,255,255,0.08);
  border:1px solid transparent;
  color:#e6f4ff;
  font-weight:600;
  cursor:pointer;
  transition:transform .12s ease, background .12s ease, border .12s ease;
}
body.page-social .viewer-actions .action-btn:hover{
  background:rgba(255,255,255,0.16);
  transform:translateY(-1px);
}
body.page-social .viewer-actions .action-btn.is-active{
  background:rgba(14,165,233,0.22);
  border-color:rgba(14,165,233,0.5);
  color:#05131f;
}
body.page-social .viewer-actions .action-btn.delete{
  background:rgba(255,78,109,0.12);
  color:#ff9fb4;
  border-color:rgba(255,78,109,0.25);
}
body.page-social .viewer-actions .action-btn.delete:hover{
  background:rgba(255,78,109,0.2);
}
body.page-social .viewer-actions .icon{
  font-size:18px;
}
body.page-social .viewer-actions .label{
  font-size:14px;
  font-weight:600;
}
body.page-social .comment-panel{
  background:rgba(5,18,31,0.8);
  border-radius:18px;
  border:1px solid rgba(148,191,224,0.14);
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-social .comment-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-weight:700;
}
body.page-social .comment-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:12px;
  max-height:220px;
  overflow-y:auto;
}
body.page-social .comment-list li{
  background:rgba(255,255,255,0.05);
  border-radius:12px;
  padding:10px 12px;
  font-size:14px;
  color:#d9e9ff;
  line-height:1.5;
}
body.page-social .comment-list strong{
  color:#8ed8ff;
}
body.page-social .comment-form{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
body.page-social .comment-form input{
  flex:1;
  min-width:160px;
  background:rgba(5,20,33,0.85);
  border:1px solid rgba(148,191,224,0.22);
  border-radius:12px;
  padding:10px 12px;
  color:#f6fbff;
  font-size:14px;
}
body.page-social .queue{
  background:rgba(7,26,42,0.9);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.18);
  padding:22px;
  box-shadow:0 28px 52px rgba(5,12,23,0.42);
  display:flex;
  flex-direction:column;
  gap:18px;
}
body.page-social .queue-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
}
body.page-social .queue-stats{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
}
body.page-social .queue-stats .stat{
  flex:1;
  min-width:120px;
  background:rgba(255,255,255,0.06);
  border-radius:12px;
  padding:10px 12px;
  display:flex;
  flex-direction:column;
  gap:4px;
  color:#9fb6c6;
}
body.page-social .queue-stats strong{
  font-size:18px;
  color:#e6f4ff;
}
body.page-social .post-rail{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:10px;
  max-height:520px;
  overflow-y:auto;
}
body.page-social .post-rail li{
  border-radius:14px;
  overflow:hidden;
}
body.page-social .post-rail button{
  width:100%;
  border:0;
  background:rgba(5,18,31,0.75);
  color:#dceeff;
  display:flex;
  gap:12px;
  padding:10px 12px;
  align-items:center;
  cursor:pointer;
  transition:background .12s ease, transform .12s ease;
}
body.page-social .post-rail button:hover{
  background:rgba(5,18,31,0.95);
  transform:translateX(2px);
}
body.page-social .post-rail li.active button{
  background:rgba(14,165,233,0.24);
  color:#03121b;
  box-shadow:0 14px 28px rgba(14,165,233,0.2);
}
body.page-social .rail-thumb{
  width:54px;
  height:54px;
  border-radius:12px;
  background:rgba(148,191,224,0.18);
  display:grid;
  place-items:center;
  font-size:20px;
  color:#9fc9eb;
  overflow:hidden;
}
body.page-social .rail-thumb.is-image{
  background:rgba(255,255,255,0.08);
}
body.page-social .rail-thumb.is-video{
  background:rgba(56,189,248,0.22);
  color:#04283b;
  font-weight:700;
}
body.page-social .rail-thumb.is-text{
  background:rgba(148,191,224,0.22);
  color:#0b2a3d;
  font-weight:700;
}
body.page-social .rail-thumb img{
  width:100%;
  height:100%;
  object-fit:cover;
}
body.page-social .rail-body{
  flex:1;
  display:flex;
  flex-direction:column;
  gap:4px;
  align-items:flex-start;
  text-align:left;
}
body.page-social .rail-title{
  font-weight:700;
  font-size:14px;
  color:inherit;
}
body.page-social .rail-time{
  font-size:12px;
  color:#9fb6c6;
}
body.page-social .composer-overlay{
  position:fixed;
  inset:0;
  background:rgba(2,9,18,0.76);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:60;
}
body.page-social .composer-overlay.hidden{
  display:none;
}
body.page-social .composer-panel{
  width:min(520px,100%);
  background:rgba(7,26,42,0.95);
  border-radius:24px;
  border:1px solid rgba(148,191,224,0.2);
  padding:24px;
  display:flex;
  flex-direction:column;
  gap:18px;
  box-shadow:0 30px 60px rgba(4,10,20,0.5);
}
body.page-social .composer-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
}
body.page-social .composer-header h2{
  margin:0;
  font-size:22px;
  font-weight:800;
}
body.page-social .composer-form{
  display:flex;
  flex-direction:column;
  gap:16px;
}
body.page-social .composer-form .field{
  display:flex;
  flex-direction:column;
  gap:6px;
  color:#a3bfdc;
}
body.page-social .composer-form textarea,
body.page-social .composer-form input[type="url"],
body.page-social .composer-form input[type="file"]{
  background:rgba(9,32,49,0.88);
  border:1px solid rgba(148,191,224,0.24);
  border-radius:12px;
  padding:10px 12px;
  color:#f1f6fc;
  font-size:15px;
  font-family:inherit;
}
body.page-social .composer-form textarea:focus,
body.page-social .composer-form input:focus{
  border-color:#0ea5ff;
  outline:none;
  box-shadow:0 0 0 2px rgba(14,165,233,0.25);
}
body.page-social .composer-form .media-preview{
  display:flex;
  align-items:center;
  gap:12px;
  background:rgba(5,18,31,0.8);
  border:1px solid rgba(148,191,224,0.22);
  border-radius:14px;
  padding:10px 12px;
}
body.page-social .composer-form .media-preview.hidden{
  display:none;
}
body.page-social .composer-form .media-preview .thumb{
  width:52px;
  height:52px;
  border-radius:12px;
  background:rgba(148,191,224,0.18);
  background-size:cover;
  background-position:center;
}
body.page-social .composer-status{
  min-height:18px;
  font-size:13px;
  color:#7ad7ff;
}
body.page-social .composer-status.error{
  color:#ff9aa5;
}
body.page-social .composer-actions{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.action-btn:disabled,
.btn:disabled{
  opacity:0.45;
  cursor:not-allowed;
}

@media (max-width:1080px){
  body.page-social .stream-main{
    grid-template-columns:1fr;
  }
  body.page-social .queue{
    order:-1;
  }
}

@media (max-width:720px){
  body.page-social{
    padding:18px 12px 36px;
  }
  body.page-social .stream-topbar{
    flex-direction:column;
    align-items:flex-start;
  }
  body.page-social .stream-topbar .top-actions{
    align-items:flex-start;
  }
  body.page-social .viewer{
    padding:18px;
  }
  body.page-social .viewer-media::before{
    padding-top:60%;
  }
  body.page-social .viewer-actions{
    flex-wrap:wrap;
  }
  body.page-social .comment-form{
    flex-direction:column;
  }
  body.page-social .queue{
    padding:18px;
  }
  body.page-social .composer-panel{
    padding:18px;
  }
}
body.page-social .post-card{
  background:rgba(7,26,42,0.85);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  padding:22px;
  display:flex;
  flex-direction:column;
  gap:18px;
  box-shadow:0 20px 38px rgba(5,12,23,0.4);
}
body.page-social .post-head{
  display:flex;
  align-items:center;
  gap:14px;
}
body.page-social .post-head .avatar{
  width:44px;
  height:44px;
  border-radius:50%;
  background:rgba(59,130,246,0.2);
  display:grid;
  place-items:center;
  font-weight:800;
  color:#9dd7ff;
  font-size:18px;
  overflow:hidden;
}
body.page-social .post-head .avatar.with-image{
  background-size:cover;
  background-position:center;
  color:transparent;
}
body.page-social .post-head .meta{
  display:flex;
  flex-direction:column;
  gap:4px;
}
body.page-social .post-head .author{
  font-weight:700;
  font-size:16px;
}
body.page-social .post-head .timestamp{
  font-size:12px;
  color:#a7bfd5;
}
body.page-social .post-head .delete-btn{
  margin-left:auto;
}
body.page-social .post-body{
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-social .post-body .caption{
  margin:0;
  font-size:16px;
  line-height:1.6;
  color:#e9f4ff;
}
body.page-social .post-body .media-slot iframe,
body.page-social .post-body .media-slot video{
  width:100%;
  aspect-ratio:16/9;
  border:0;
  border-radius:16px;
  background:#01070d;
  box-shadow:0 20px 44px rgba(0,0,0,0.45);
}
body.page-social .post-body .media-slot img{
  width:100%;
  border-radius:16px;
  max-height:60vh;
  object-fit:cover;
  box-shadow:0 20px 44px rgba(0,0,0,0.45);
}
body.page-social .post-foot{
  display:flex;
  gap:12px;
}
body.page-social .post-comments{
  border-top:1px solid rgba(148,191,224,0.16);
  padding-top:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
body.page-social .post-comments h4{
  margin:0;
  font-size:14px;
  color:#a7bfd5;
}
body.page-social .comment-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:8px;
  font-size:13px;
  color:#d4e7ff;
}
body.page-social .comment-list strong{
  color:#9dd7ff;
}
body.page-social .comment-form{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
body.page-social .comment-form .field{
  flex:1;
  margin:0;
}
body.page-social .comment-form input{
  width:100%;
  padding:9px 12px;
}
body.page-social .comment-form button{
  align-self:flex-start;
}
body.page-social .social-right .btn.secondary{
  align-self:flex-start;
}
body.page-social .sr-only{
  position:absolute;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  overflow:hidden;
  clip:rect(0,0,0,0);
  white-space:nowrap;
  border:0;
}
@media (max-width:1080px){
  body.page-social{
    padding:24px 16px 48px;
  }
  body.page-social .social-layout{
    grid-template-columns:1fr;
  }
  body.page-social .social-right,
  body.page-social .social-sidebar{
    order:1;
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    gap:16px;
  }
  body.page-social .social-feed{
    order:0;
  }
}
@media (max-width:720px){
  body.page-social{
    padding:24px 12px 48px;
  }
  body.page-social .social-topbar{
    position:static;
    width:100%;
    flex-direction:column;
    align-items:flex-start;
  }
  body.page-social .top-actions{
    width:100%;
    justify-content:flex-start;
  }
  body.page-social .composer-actions{
    flex-direction:column;
    align-items:flex-start;
  }
  body.page-social .comment-form{
    flex-direction:column;
    align-items:stretch;
  }
}
body.page-offline{
  min-height:100%;
  margin:0;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6eef8;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:32px 16px;
}
body.page-offline .offline-card{
  background:rgba(7,27,42,0.9);
  border-radius:18px;
  box-shadow:0 24px 48px rgba(0,0,0,0.6);
  max-width:560px;
  width:100%;
  padding:32px;
  display:flex;
  flex-direction:column;
  gap:24px;
}
body.page-offline h1{
  margin:0 0 6px;
  font-size:26px;
  font-weight:800;
}
body.page-offline .subtitle{
  margin:0;
  color:var(--muted);
  font-size:14px;
}
body.page-offline .offline-section{
  display:flex;
  flex-direction:column;
  gap:12px;
}
body.page-offline .action-row{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}
body.page-offline .offline-btn{
  border:0;
  border-radius:12px;
  padding:10px 16px;
  font-weight:700;
  cursor:pointer;
  transition:transform .12s ease, box-shadow .12s ease;
}
body.page-offline .offline-btn.primary{
  background:var(--accent);
  color:#042033;
  box-shadow:0 14px 30px rgba(57,197,255,0.4);
}
body.page-offline .offline-btn.primary:hover{
  transform:translateY(-3px);
}
body.page-offline .offline-btn.secondary{
  background:transparent;
  color:var(--muted);
  border:1px solid rgba(255,255,255,0.08);
}
body.page-offline .status-text{
  font-size:13px;
  color:var(--muted);
  margin:0;
}
body.page-offline .offline-list{
  margin:0;
  padding-left:20px;
  display:flex;
  flex-direction:column;
  gap:6px;
  color:#d5e4f2;
}
@media (max-width:540px){
  body.page-offline{
    padding:24px 12px;
  }
  body.page-offline .offline-card{
    padding:24px;
  }
}
body.page-chats{
  min-height:100%;
  margin:0;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6eef8;
  display:flex;
  align-items:stretch;
  justify-content:center;
  padding:24px 12px 36px;
}
body.page-chats .chat-shell{
  width:100%;
  max-width:1280px;
  display:flex;
  flex-direction:column;
  gap:18px;
}
body.page-chats .chat-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
}
body.page-chats .chat-header h1{
  margin:0;
  font-size:28px;
  font-weight:800;
}
body.page-chats .chat-header .subtitle{
  margin:6px 0 0;
  color:var(--muted);
  font-size:14px;
}
body.page-chats .profile-chip{
  padding:8px 16px;
  border-radius:999px;
  background:rgba(255,255,255,0.12);
  font-weight:700;
  font-size:14px;
}
body.page-chats .chat-layout{
  display:grid;
  grid-template-columns:320px 1fr;
  gap:18px;
}
body.page-chats .chat-sidebar{
  background:rgba(7,27,42,0.85);
  border-radius:18px;
  border:1px solid rgba(255,255,255,0.08);
  padding:20px;
  display:flex;
  flex-direction:column;
  gap:18px;
  box-shadow:0 24px 50px rgba(0,0,0,0.45);
}
body.page-chats .chat-section h2{
  margin:0 0 10px;
  font-size:15px;
  text-transform:uppercase;
  letter-spacing:0.6px;
  color:#b8cde0;
}
body.page-chats .chat-section form{
  display:flex;
  flex-direction:column;
  gap:10px;
}
body.page-chats label span{
  display:block;
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.7px;
  color:#8fa6bc;
  margin-bottom:4px;
}
body.page-chats input,
body.page-chats textarea,
body.page-chats select{
  width:100%;
  background:rgba(10,30,48,0.85);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:10px;
  padding:8px 10px;
  color:#f3f8ff;
  font-family:inherit;
  font-size:14px;
  outline:none;
}
body.page-chats textarea{
  resize:vertical;
}
body.page-chats input:focus,
body.page-chats textarea:focus,
body.page-chats select:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(57,197,255,0.2);
}
body.page-chats .room-list{
  list-style:none;
  padding:0;
  margin:0;
  display:flex;
  flex-direction:column;
  gap:8px;
}
body.page-chats .room-btn{
  width:100%;
  border:1px solid rgba(255,255,255,0.05);
  border-radius:12px;
  background:rgba(8,22,39,0.8);
  color:#e6eef8;
  text-align:left;
  padding:10px 12px;
  cursor:pointer;
  transition:transform .12s ease, border-color .12s ease, box-shadow .12s ease;
}
body.page-chats .room-btn:hover{
  transform:translateY(-2px);
  border-color:rgba(57,197,255,0.6);
  box-shadow:0 12px 24px rgba(0,0,0,0.4);
}
body.page-chats .room-btn.active{
  border-color:var(--accent);
  box-shadow:0 12px 28px rgba(57,197,255,0.35);
}
body.page-chats .room-name{
  font-weight:700;
  font-size:15px;
}
body.page-chats .tiny{
  font-size:12px;
}
body.page-chats .btn{
  border:0;
  border-radius:12px;
  padding:8px 14px;
  font-weight:700;
  cursor:pointer;
  color:#031522;
  background:var(--accent);
  transition:transform .12s ease, box-shadow .12s ease;
}
body.page-chats .btn.primary{
  background:linear-gradient(135deg,#39c5ff,#23a6ff);
  color:#06283a;
  box-shadow:0 16px 34px rgba(35,166,255,0.4);
}
body.page-chats .btn.secondary{
  background:rgba(255,255,255,0.08);
  color:#d2e9ff;
  border:1px solid rgba(255,255,255,0.18);
}
body.page-chats .btn.small{
  padding:6px 12px;
  font-size:13px;
}
body.page-chats .btn.tiny{
  padding:6px 10px;
  font-size:12px;
}
body.page-chats .btn.danger{
  background:rgba(244,63,94,0.16);
  color:#f8719d;
  border:1px solid rgba(244,63,94,0.35);
}
body.page-chats .btn:disabled{
  opacity:0.45;
  pointer-events:none;
}
body.page-chats .chat-main{
  background:rgba(7,23,36,0.9);
  border-radius:22px;
  border:1px solid rgba(255,255,255,0.08);
  display:grid;
  grid-template-columns:1fr 240px;
  overflow:hidden;
  box-shadow:0 28px 60px rgba(0,0,0,0.5);
}
body.page-chats .active-room{
  display:flex;
  flex-direction:column;
  padding:20px;
  gap:16px;
}
body.page-chats .room-header{
  display:flex;
  justify-content:space-between;
  gap:18px;
  align-items:center;
}
body.page-chats .room-header h2{
  margin:0;
  font-size:22px;
  font-weight:800;
}
body.page-chats .muted{
  color:var(--muted);
}
body.page-chats .room-actions{
  display:flex;
  align-items:center;
  gap:12px;
}
body.page-chats .room-pill{
  padding:6px 12px;
  border-radius:999px;
  background:rgba(255,255,255,0.12);
  font-size:12px;
  font-weight:700;
  letter-spacing:0.6px;
  text-transform:uppercase;
  color:#9dd7ff;
}
body.page-chats .chat-scroll{
  flex:1;
  overflow-y:auto;
  background:rgba(5,17,30,0.8);
  border:1px solid rgba(255,255,255,0.05);
  border-radius:18px;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-chats .chat-scroll ul{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-chats .empty-chat{
  text-align:center;
  color:var(--muted);
  font-size:14px;
}
body.page-chats .message{
  display:flex;
}
body.page-chats .message .bubble{
  background:linear-gradient(135deg,rgba(57,197,255,0.2),rgba(8,41,62,0.9));
  border-radius:14px;
  padding:12px 14px;
  box-shadow:0 14px 28px rgba(7,19,32,0.46);
  width:100%;
}
body.page-chats .message header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
  font-size:12px;
  color:#9ec5de;
}
body.page-chats .message .text{
  margin:0;
  color:#f2f8ff;
  white-space:pre-wrap;
  word-break:break-word;
}
body.page-chats .message .image-block{
  margin-top:10px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
body.page-chats .message .image-block img{
  max-width:100%;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.12);
  box-shadow:0 12px 24px rgba(0,0,0,0.45);
}
body.page-chats .message .image-block .caption{
  color:#9ec5de;
}
body.page-chats .chat-composer{
  display:flex;
  gap:12px;
  align-items:flex-end;
}
body.page-chats .chat-composer input{
  flex:1;
}
body.page-chats .chat-composer .attach-block{
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:flex-start;
  flex:0 0 auto;
  max-width:160px;
}
body.page-chats .chat-composer .image-preview{
  background:rgba(4,21,35,0.8);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:12px;
  padding:8px;
  display:flex;
  flex-direction:column;
  gap:6px;
  max-width:160px;
}
body.page-chats .chat-composer .image-preview img{
  width:100%;
  max-height:120px;
  object-fit:cover;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.08);
}
body.page-chats .chat-composer .image-preview .tiny{
  color:var(--muted);
}
body.page-chats .chat-composer .image-preview .btn{
  align-self:flex-start;
}
body.page-chats .member-pane{
  background:rgba(4,21,35,0.9);
  border-left:1px solid rgba(255,255,255,0.05);
  padding:18px 18px 18px 16px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-chats .member-pane header{
  display:flex;
  align-items:center;
  justify-content:space-between;
}
body.page-chats .member-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:8px;
}
body.page-chats .member-list .dot{
  width:8px;
  height:8px;
  border-radius:50%;
  background:#58f29d;
  margin-right:8px;
  display:inline-block;
}
body.page-chats .member-list li{
  display:flex;
  align-items:center;
  font-size:13px;
  color:#d4eaff;
}
body.page-chats .member-note{
  font-size:12px;
}
body.page-chats .invite-code{
  display:flex;
  flex-direction:column;
  gap:6px;
  background:rgba(57,197,255,0.12);
  border:1px solid rgba(57,197,255,0.32);
  border-radius:12px;
  padding:12px;
}
body.page-chats .invite-code .label{
  font-size:11px;
  text-transform:uppercase;
  letter-spacing:0.6px;
  color:#9dd7ff;
}
body.page-chats .invite-code code{
  background:rgba(4,21,35,0.7);
  padding:6px 8px;
  border-radius:8px;
  font-family:monospace;
  font-size:13px;
  letter-spacing:1px;
}
.hidden{
  display:none !important;
}
@media (max-width:960px){
  body.page-chats .chat-layout{
    grid-template-columns:1fr;
  }
  body.page-chats .chat-main{
    grid-template-columns:1fr;
  }
  body.page-chats .member-pane{
    border-left:0;
    background:rgba(4,21,35,0.7);
    border-top:1px solid rgba(255,255,255,0.05);
    border-radius:0 0 18px 18px;
    padding-top:16px;
  }
}
body.page-settings{
  min-height:100%;
  margin:0;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6eef8;
  padding:32px 16px 48px;
  display:flex;
  justify-content:center;
}
body.page-settings .settings-shell{
  width:100%;
  max-width:1200px;
  display:flex;
  flex-direction:column;
  gap:22px;
}
body.page-settings .settings-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:16px;
}
body.page-settings .settings-header h1{
  margin:0;
  font-size:30px;
  font-weight:800;
}
body.page-settings .settings-header .subtitle{
  margin:6px 0 0;
  color:var(--muted);
  font-size:14px;
}
body.page-settings .btn{
  border:0;
  border-radius:12px;
  padding:8px 16px;
  font-weight:700;
  cursor:pointer;
  transition:transform .12s ease, box-shadow .12s ease;
  font-family:inherit;
}
body.page-settings .btn.primary{
  background:linear-gradient(135deg,#39c5ff,#23a6ff);
  color:#06283a;
  box-shadow:0 16px 34px rgba(35,166,255,0.4);
}
body.page-settings .btn.secondary{
  background:rgba(255,255,255,0.08);
  color:#d2e9ff;
  border:1px solid rgba(255,255,255,0.18);
}
body.page-settings .btn.tertiary{
  background:transparent;
  color:#9fc9eb;
  border:1px solid rgba(159,201,235,0.4);
}
body.page-settings .btn:disabled{
  opacity:.5;
  pointer-events:none;
}
body.page-settings .settings-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
  gap:20px;
}
body.page-settings .settings-card{
  background:rgba(6,24,39,0.92);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  padding:22px;
  display:flex;
  flex-direction:column;
  gap:16px;
  box-shadow:0 26px 52px rgba(0,0,0,0.5);
}
body.page-settings .settings-card header h2{
  margin:0;
  font-size:18px;
  font-weight:800;
}
body.page-settings .settings-card header p{
  margin:6px 0 0;
  color:var(--muted);
  font-size:13px;
}
body.page-settings form{
  display:flex;
  flex-direction:column;
  gap:14px;
}
body.page-settings label span{
  display:block;
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.6px;
  margin-bottom:6px;
  color:#8fa6bc;
}
body.page-settings input,
body.page-settings textarea,
body.page-settings select{
  width:100%;
  background:rgba(10,30,48,0.88);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:12px;
  padding:10px 12px;
  color:#f3f8ff;
  font-size:14px;
  font-family:inherit;
  outline:none;
}
body.page-settings textarea{
  resize:vertical;
}
body.page-settings input:focus,
body.page-settings textarea:focus,
body.page-settings select:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(57,197,255,0.2);
}
body.page-settings .actions{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
body.page-settings .note{
  font-size:12px;
  color:var(--muted);
}
body.page-settings .toggle{
  display:flex;
  align-items:center;
  gap:14px;
  background:rgba(7,25,40,0.8);
  border:1px solid rgba(255,255,255,0.06);
  border-radius:14px;
  padding:10px 12px;
  cursor:pointer;
}
body.page-settings .toggle strong{
  display:block;
  font-size:14px;
  color:#e6f2ff;
}
body.page-settings .toggle small{
  display:block;
  font-size:12px;
  color:var(--muted);
}
body.page-settings .toggle input{
  position:absolute;
  opacity:0;
  pointer-events:none;
}
body.page-settings .toggle .slider{
  width:46px;
  height:24px;
  border-radius:999px;
  background:rgba(255,255,255,0.15);
  position:relative;
  flex-shrink:0;
  transition:background .2s ease;
}
body.page-settings .toggle .slider::after{
  content:'';
  position:absolute;
  top:3px;
  left:3px;
  width:18px;
  height:18px;
  border-radius:50%;
  background:#071226;
  transition:transform .2s ease, background .2s ease;
  box-shadow:0 4px 10px rgba(0,0,0,0.4);
}
body.page-settings .toggle input:checked + .slider{
  background:linear-gradient(135deg,#39c5ff,#0ea5ff);
}
body.page-settings .toggle input:checked + .slider::after{
  transform:translateX(22px);
  background:#f2fbff;
}
body.page-settings .storage-actions{
  display:flex;
  flex-direction:column;
  gap:10px;
}
body.page-settings .storage-status{
  margin:0;
}
body.page-settings .flash{
  animation:noteFlash 1.2s ease;
}
@keyframes noteFlash{
  0%{color:#39c5ff;}
  100%{color:var(--muted);}
}
@media (max-width:720px){
  body.page-settings{
    padding:24px 12px 36px;
  }
  body.page-settings .settings-header{
    flex-direction:column;
    align-items:flex-start;
  }
  body.page-settings .settings-grid{
    grid-template-columns:1fr;
  }
}
}body.page-social{
  min-height:100%;
  margin:0;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6f1ff;
  padding:32px 16px 48px;
  display:flex;
  justify-content:center;
}
body.page-social .social-shell{
body.page-carpai{
  min-height:100vh;
  margin:0;
  font-family:var(--ui-font);
  background:linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e6f4ff;
  display:flex;
  flex-direction:column;
  gap:24px;
  padding:32px 16px 48px;
}

.page-carpai .ai-topbar{
  width:min(1140px,100%);
  margin:0 auto;
  background:rgba(7,26,42,0.92);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  padding:20px 24px;
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:18px;
  box-shadow:0 28px 54px rgba(5,12,23,0.45);
}

.page-carpai .brand h1{
  margin:0;
  font-size:30px;
  font-weight:800;
  letter-spacing:-0.4px;
}

.page-carpai .beta-pill{
  display:inline-flex;
  align-items:center;
  padding:4px 12px;
  margin-left:10px;
  border-radius:999px;
  font-size:11px;
  letter-spacing:0.8px;
  text-transform:uppercase;
  background:rgba(16,185,129,0.18);
  color:#6ee7b7;
}

.page-carpai .tagline{
  margin:8px 0 0;
  color:#9fb6c6;
  font-size:14px;
}

.page-carpai .top-actions{
  display:flex;
  flex-direction:column;
  gap:12px;
  align-items:flex-end;
}

.page-carpai nav{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}

.page-carpai .chip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 16px;
  border-radius:999px;
  background:rgba(255,255,255,0.08);
  color:#e6f4ff;
  font-size:13px;
  font-weight:600;
  text-decoration:none;
  transition:transform .12s ease, background .12s ease;
}

.page-carpai .chip:hover{
  background:rgba(255,255,255,0.18);
  transform:translateY(-1px);
}

.page-carpai .btn{
  border:1px solid rgba(148,191,224,0.3);
  border-radius:12px;
  padding:8px 14px;
  background:rgba(255,255,255,0.05);
  color:#e6f4ff;
  font-weight:600;
  cursor:pointer;
  transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
}

.page-carpai .btn:hover{
  background:rgba(255,255,255,0.12);
  transform:translateY(-1px);
}

.page-carpai .btn.primary{
  background:linear-gradient(135deg,#0ea5ff,#38bdf8);
  color:#042033;
  border:0;
  box-shadow:0 18px 32px rgba(14,165,233,0.35);
}

.page-carpai .btn.primary:hover{
  transform:translateY(-2px);
  box-shadow:0 22px 36px rgba(14,165,233,0.4);
}

.page-carpai .btn.secondary{
  background:rgba(255,255,255,0.08);
  color:#e6f4ff;
}

.page-carpai .btn.ghost{
  background:transparent;
  color:#9fc9eb;
}

.page-carpai .ai-layout{
  width:min(1140px,100%);
  margin:0 auto;
  display:grid;
  grid-template-columns:260px minmax(0,1fr) 260px;
  gap:20px;
  align-items:start;
}

.page-carpai .card{
  background:rgba(7,26,42,0.88);
  border-radius:20px;
  border:1px solid rgba(148,191,224,0.16);
  padding:20px;
  box-shadow:0 26px 50px rgba(5,12,23,0.4);
  display:flex;
  flex-direction:column;
  gap:14px;
}

.page-carpai .ai-sidebar,
.page-carpai .ai-right{
  display:flex;
  flex-direction:column;
  gap:18px;
}

.page-carpai .prompt-card h2,
.page-carpai .tips-card h2,
.page-carpai .knowledge-card h2{
  margin:0;
  font-size:18px;
  font-weight:800;
}

.page-carpai .prompt-list{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.page-carpai .prompt-btn{
  width:100%;
  text-align:left;
  border:0;
  border-radius:12px;
  padding:10px 14px;
  background:rgba(255,255,255,0.06);
  color:#dae8ff;
  font-weight:600;
  cursor:pointer;
  transition:transform .12s ease, background .12s ease;
}

.page-carpai .prompt-btn:hover{
  background:rgba(255,255,255,0.12);
  transform:translateY(-1px);
}

.page-carpai .tips-card ul{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:8px;
  color:#9fb6c6;
  font-size:13px;
}

.page-carpai .knowledge-card dl{
  margin:0;
  display:grid;
  gap:10px;
}

.page-carpai .knowledge-card dt{
  font-weight:700;
  color:#e6f4ff;
}

.page-carpai .knowledge-card dd{
  margin:4px 0 0;
  color:#9fb6c6;
  font-size:13px;
}

.page-carpai .ai-chat{
  min-height:520px;
  padding:24px;
  gap:20px;
  display:flex;
  flex-direction:column;
}

.page-carpai .typing{
  font-size:13px;
  color:#9fb6c6;
}

.page-carpai .typing.hidden{
  display:none;
}

.page-carpai .chat-log{
  list-style:none;
  margin:0;
  padding:0;
  display:flex;
  flex-direction:column;
  gap:16px;
  overflow-y:auto;
  max-height:520px;
}

.page-carpai .message{
  display:flex;
  flex-direction:column;
  gap:6px;
}

.page-carpai .message .bubble{
  background:linear-gradient(135deg,rgba(14,165,233,0.18),rgba(8,27,43,0.85));
  border-radius:16px;
  padding:14px 16px;
  color:#eaf5ff;
  line-height:1.6;
  box-shadow:0 18px 32px rgba(3,10,18,0.46);
}

.page-carpai .message.bot .bubble{
  background:rgba(59,130,246,0.2);
  border:1px solid rgba(148,191,224,0.24);
}

.page-carpai .message time{
  font-size:12px;
  color:#8fa6bc;
}

.page-carpai .chat-form{
  display:flex;
  flex-direction:column;
  gap:12px;
}

.page-carpai .chat-form input{
  background:rgba(7,26,42,0.85);
  border:1px solid rgba(148,191,224,0.2);
  border-radius:12px;
  padding:12px 14px;
  color:#f6fbff;
  font-size:16px;
  outline:none;
}

.page-carpai .chat-form input:focus{
  border-color:#0ea5ff;
  box-shadow:0 0 0 2px rgba(14,165,233,0.25);
}

.page-carpai .form-actions{
  display:flex;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
}

.page-carpai .chat-link{
  display:inline-block;
  margin-top:8px;
  color:#8ed8ff;
  text-decoration:none;
  font-weight:600;
}

.page-carpai .chat-link:hover{
  text-decoration:underline;
}

@media (max-width:1040px){
  .page-carpai .ai-layout{
    grid-template-columns:1fr;
  }
  .page-carpai .ai-right,
  .page-carpai .ai-sidebar{
    order:1;
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    gap:16px;
  }
  .page-carpai .ai-chat{
    order:0;
  }
}

@media (max-width:720px){
  body.page-carpai{
    padding:24px 12px 36px;
  }
  .page-carpai .ai-topbar{
    flex-direction:column;
    align-items:flex-start;
  }
  .page-carpai .top-actions{
    align-items:flex-start;
  }
  .page-carpai .form-actions{
    flex-direction:column;
    align-items:stretch;
  }
}
    body.route-shell{min-height:100vh;}
    [data-route]{display:none;}
    [data-route].is-active{display:block;}
  </style>
</head>
<body class="route-shell page-home">
  <div id="app">
    <section data-route="home" data-title="carp.edu" data-body-class="page-home" class="is-active">
<div class="page">
    <div class="topbar">
      <a class="top-btn" href="#account">acount mange ment</a>
      <a class="top-btn" href="#social">social feed</a>
      <a class="top-btn" href="#carpai">carp ai</a>
      <a class="top-btn" href="#settings">settings</a>
    </div>

    <section class="big-banner" aria-hidden="false">
      <div class="big-top">welcome to carp</div>
      <div class="big-bottom" id="bannerMessage">make a acount</div>
    </section>

    <div class="bottom-row" aria-label="five small banners">
      <a class="small-banner" href="#carpfish" target="_self">carpfish games</a>
      <a class="small-banner" href="#social" target="_self">social feed</a>
      <a class="small-banner" href="#carpai" target="_self">carp ai</a>
      <a class="small-banner" href="#chats" target="_self">private chats</a>
      <a class="small-banner" href="#download" target="_self" rel="noopener">offline setup</a>
    </div>
  </div>
    </section>
    <section data-route="account" data-title="Account Management" data-body-class="page-account">
<div class="account-shell">
    <header class="account-header">
      <div class="page-number">1</div>
      <a class="page-link" href="#home">Back</a>
    </header>

    <nav class="account-tabs" role="tablist" aria-label="Account sections">
      <button id="tab-account" class="tab-link is-active" type="button" role="tab" aria-selected="true" aria-controls="panel-account" data-tab="account">Profile</button>
      <button id="tab-posts" class="tab-link" type="button" role="tab" aria-selected="false" aria-controls="panel-posts" data-tab="posts">Posts</button>
      <button id="tab-directory" class="tab-link" type="button" role="tab" aria-selected="false" aria-controls="panel-directory" data-tab="directory">Directory</button>
    </nav>

    <main class="account-main">
      <section id="panel-account" class="card account-form-card tab-panel" data-tab-panel="account" role="tabpanel" aria-labelledby="tab-account">
        <h1>Create Your Account</h1>
        <p class="account-subtext">Complete the form so we can save your profile and posts.</p>
        <form id="accountForm" novalidate>
          <div class="field-grid">
            <label class="field">
              <span>First Name</span>
              <input type="text" name="firstName" required autocomplete="given-name" />
            </label>
            <label class="field">
              <span>Last Name</span>
              <input type="text" name="lastName" required autocomplete="family-name" />
            </label>
          </div>
          <label class="field">
            <span>Username</span>
            <input type="text" name="username" required minlength="3" autocomplete="username" />
          </label>
          <label class="field">
            <span>Email</span>
            <input type="email" name="email" required autocomplete="email" />
          </label>
          <label class="field">
            <span>Profile Picture (optional)</span>
            <input type="file" name="avatar" accept="image/*" />
          </label>
          <button type="submit" class="btn primary">Create Account</button>
          <p id="accountStatus" class="account-status" role="status" aria-live="polite"></p>
        </form>
        <div id="profilePreview" class="profile-preview" hidden>
          <img id="profileAvatar" alt="Profile preview" />
          <div class="profile-preview-info">
            <div id="profileName"></div>
            <div id="profileEmail"></div>
          </div>
        </div>
      </section>

      <section id="panel-posts" class="card account-posts-card tab-panel" data-tab-panel="posts" role="tabpanel" aria-labelledby="tab-posts" hidden>
        <div class="posts-header">
          <h2>Your Posts</h2>
          <button id="clearPosts" class="btn subtle" type="button" disabled>Clear All</button>
        </div>
        <form id="postForm" class="post-form" hidden>
          <label class="field">
            <span>Share something with your friends</span>
            <textarea name="postBody" rows="3" maxlength="500" required placeholder="Write a caption or thought..."></textarea>
          </label>
          <button type="submit" class="btn primary">Add Post</button>
        </form>
        <ul id="postList" class="post-list" aria-label="Saved posts"></ul>
        <p id="noPostsHint" class="hint">Create an account and start sharing to see your posts here.</p>
      </section>

      <section id="panel-directory" class="card account-db-card tab-panel" data-tab-panel="directory" role="tabpanel" aria-labelledby="tab-directory" hidden>
        <div class="posts-header">
          <h2>Account Directory</h2>
          <button id="refreshAccounts" class="btn subtle" type="button">Refresh</button>
        </div>
        <ul id="accountsList" class="account-list" aria-label="Accounts"></ul>
        <p id="accountsEmpty" class="hint">No accounts stored yet.</p>
      </section>
    </main>
  </div>
    </section>
    <section data-route="social" data-title="CarpStream Viewer" data-body-class="page-social">
<header class="stream-topbar">
    <div class="brand">
      <span class="logo-dot" aria-hidden="true"></span>
      <div>
        <h1>CarpStream</h1>
        <p class="tagline">Jump into every Carp post fullscreen with instant reactions.</p>
      </div>
    </div>
    <div class="top-actions">
      <nav aria-label="Main navigation">
        <a href="#home" class="chip">home</a>
        <a href="#account" class="chip">account</a>
        <a href="#carpfish" class="chip">games</a>
        <a href="#settings" class="chip">settings</a>
      </nav>
      <button class="btn primary" id="openComposer" type="button">+ New post</button>
    </div>
  </header>

  <main class="stream-main">
    <section class="viewer" id="viewer">
      <div class="viewer-media" id="viewerMedia">
        <div class="viewer-empty" id="viewerEmpty">
          Select a clip or photo from the list to start watching.
        </div>
      </div>
      <div class="viewer-panel">
        <div class="viewer-header">
          <div class="viewer-meta">
            <span class="viewer-author" id="viewerAuthor"></span>
            <time id="viewerTime"></time>
          </div>
          <div class="viewer-controls">
            <button class="btn accent" id="fullscreenAction" type="button">Fullscreen</button>
          </div>
        </div>
        <p class="viewer-caption" id="viewerCaption"></p>
        <div class="viewer-actions">
          <button class="action-btn" id="likeAction" type="button" aria-label="Like post">
            <span class="icon" aria-hidden="true">&#x2764;</span>
            <span id="likeCount">0</span>
          </button>
          <button class="action-btn" id="dislikeAction" type="button" aria-label="Dislike post">
            <span class="icon" aria-hidden="true">&#x2716;</span>
            <span id="dislikeCount">0</span>
          </button>
          <button class="action-btn" id="repostAction" type="button" aria-label="Repost">
            <span class="icon" aria-hidden="true">&#x21ba;</span>
            <span id="repostCount">0</span>
          </button>
          <button class="action-btn" id="shareAction" type="button" aria-label="Share post">
            <span class="icon" aria-hidden="true">&#x21aa;</span>
            <span class="label">Share</span>
          </button>
          <button class="action-btn delete" id="deleteAction" type="button">Delete</button>
        </div>
        <ul class="comment-list" id="commentList"></ul>
        <form id="commentForm" class="comment-form" autocomplete="off">
          <input type="text" id="commentInput" name="comment" placeholder="Add a commentâ€¦" maxlength="200" required />
          <button type="submit" class="btn secondary">Comment</button>
        </form>
      </section>
    </section>

    <aside class="queue">
      <div class="queue-header">
        <h2>All posts</h2>
        <button class="btn ghost" id="openComposerRail" type="button">+ New</button>
      </div>
      <div class="queue-stats">
        <div class="stat">
          <span>Today's posts</span>
          <strong id="todayCount">0</strong>
        </div>
        <div class="stat">
          <span>Total likes</span>
          <strong id="totalLikes">0</strong>
        </div>
      </div>
      <ul class="post-rail" id="postRail" aria-label="Post list"></ul>
    </aside>
  </main>

  <div class="composer-overlay hidden" id="composerOverlay" role="dialog" aria-modal="true">
    <section class="composer-panel">
      <header class="composer-header">
        <h2>Create a post</h2>
        <button class="btn ghost close" type="button" id="closeComposer">Close</button>
      </header>
      <form id="composerForm" class="composer-form" novalidate>
        <label class="field">
          <span>Caption</span>
          <textarea id="composerCaption" name="caption" rows="3" maxlength="280" placeholder="What's happening?" required></textarea>
        </label>

        <label class="field">
          <span>Media file</span>
          <input type="file" id="composerFile" name="mediaFile" accept="video/*,image/*" />
          <small class="hint">Optional: mp4, mov, webm, png, jpg, gif (max 5MB).</small>
        </label>

        <div class="divider"><span>or</span></div>

        <label class="field">
          <span>Media URL</span>
          <input type="url" id="composerUrl" name="mediaUrl" placeholder="https:// (YouTube, image link, etc.)" />
          <small class="hint">Leave blank for text-only posts.</small>
        </label>

        <div class="media-preview hidden" id="composerPreview">
          <div class="thumb" id="composerThumb" aria-hidden="true"></div>
          <div>
            <p id="composerFileName"></p>
            <button class="btn tiny ghost" type="button" id="clearComposerFile">Remove file</button>
          </div>
        </div>

        <p id="composerStatus" class="composer-status" role="status" aria-live="assertive"></p>

        <footer class="composer-actions">
          <button type="button" class="btn ghost" id="cancelComposer">Cancel</button>
          <button type="submit">Post</button>
        </footer>
      </form>
    </section>
  </div>
    </section>
    <section data-route="settings" data-title="Carp Settings" data-body-class="page-settings">
<div class="settings-shell">
    <header class="settings-header">
      <div>
        <h1>Settings</h1>
        <p class="subtitle">Tune Carp to fit your vibe â€” update your account, control privacy, and customize themes.</p>
      </div>
      <a class="btn tertiary" href="#home">Back to Home</a>
    </header>

    <div class="settings-grid">
      <section class="settings-card">
        <header>
          <h2>Profile</h2>
          <p>Update your display name and contact info.</p>
        </header>
        <form id="profileForm" autocomplete="off">
          <label>
            <span>Display name</span>
            <input type="text" id="profileName" maxlength="24" />
          </label>
          <label>
            <span>Email</span>
            <input type="email" id="profileEmail" maxlength="60" />
          </label>
          <label>
            <span>Status message</span>
            <textarea id="profileStatus" rows="2" maxlength="120"></textarea>
          </label>
          <div class="actions">
            <button type="submit" class="btn primary">Save profile</button>
            <span class="note" id="profileNote"></span>
          </div>
        </form>
      </section>

      <section class="settings-card">
        <header>
          <h2>Privacy &amp; Safety</h2>
          <p>Control who can find you and what you share.</p>
        </header>
        <form id="privacyForm">
          <label class="toggle">
            <input type="checkbox" id="privacyDiscoverable" />
            <span class="slider"></span>
            <div>
              <strong>Allow friend discovery</strong>
              <small>Let others search your username.</small>
            </div>
          </label>
          <label class="toggle">
            <input type="checkbox" id="privacyPublicFeed" />
            <span class="slider"></span>
            <div>
              <strong>Show posts on public feed</strong>
              <small>Uncheck to keep your posts private.</small>
            </div>
          </label>
          <label class="toggle">
            <input type="checkbox" id="privacyRoomInvites" />
            <span class="slider"></span>
            <div>
              <strong>Allow invite requests</strong>
              <small>Friends can send you private room invites.</small>
            </div>
          </label>
          <div class="actions">
            <button type="submit" class="btn primary">Save privacy</button>
            <span class="note" id="privacyNote"></span>
          </div>
        </form>
      </section>

      <section class="settings-card">
        <header>
          <h2>Appearance</h2>
          <p>Switch themes and interface tweaks.</p>
        </header>
        <form id="appearanceForm">
          <label>
            <span>Theme</span>
            <select id="themeChoice">
              <option value="ocean">Ocean deep</option>
              <option value="sunset">Sunset glow</option>
              <option value="forest">Forest mist</option>
            </select>
          </label>
          <label class="toggle">
            <input type="checkbox" id="appearanceAnimations" checked />
            <span class="slider"></span>
            <div>
              <strong>Motion effects</strong>
              <small>Disable if you prefer a calm experience.</small>
            </div>
          </label>
          <label class="toggle">
            <input type="checkbox" id="appearanceHighContrast" />
            <span class="slider"></span>
            <div>
              <strong>High contrast text</strong>
              <small>Boost readability across the site.</small>
            </div>
          </label>
          <div class="actions">
            <button type="submit" class="btn primary">Save appearance</button>
            <span class="note" id="appearanceNote"></span>
          </div>
        </form>
      </section>

      <section class="settings-card">
        <header>
          <h2>Security</h2>
          <p>Keep your account locked down.</p>
        </header>
        <form id="securityForm" autocomplete="off">
          <label>
            <span>Current password</span>
            <input type="password" id="currentPassword" autocomplete="new-password" />
          </label>
          <label>
            <span>New password</span>
            <input type="password" id="newPassword" autocomplete="new-password" />
          </label>
          <label>
            <span>Confirm new password</span>
            <input type="password" id="confirmPassword" autocomplete="new-password" />
          </label>
          <div class="actions">
            <button type="submit" class="btn primary">Update password</button>
            <span class="note" id="securityNote"></span>
          </div>
        </form>
      </section>

      <section class="settings-card">
        <header>
          <h2>Downloads &amp; storage</h2>
          <p>Manage offline data and exports.</p>
        </header>
        <div class="storage-actions">
          <button class="btn secondary" id="refreshOffline">Refresh offline cache</button>
          <button class="btn secondary" id="clearOffline">Clear cached data</button>
          <button class="btn secondary" id="exportData">Export my data</button>
        </div>
        <p class="storage-status note" id="storageNote">Offline cache last updated: <span id="offlineUpdated">never</span></p>
      </section>
    </div>
  </div>
    </section>
    <section data-route="carpfish" data-title="Carpfish Games" data-body-class="page-carpfish">
<div class="container">
    <header>
      <div>
        <h1>Carpfish - Button Board</h1>
        <div class="subtitle">Pick a number to open an empty game panel.</div>
      </div>
      <div class="controls">
        <a href="#home" class="btn">Home</a>
        <button id="refreshBtn" class="small">Reload</button>
        <button id="helpBtn" class="small">Help</button>
      </div>
    </header>

    <main id="mainArea">
      <div id="listView">
        <div class="muted" style="padding:24px;text-align:center">Loading buttons...</div>
      </div>

      <div id="gameView" style="display:none">
        <div class="backbar">
          <div class="game-header">
            <div class="game-title" id="gameTitle">Game</div>
            <div style="width:10px"></div>
            <div class="score-pill" id="scorePill">Score</div>
          </div>
          <div style="flex:1"></div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="restartBtn" class="btn">Restart</button>
            <button id="backBtn" class="small">Back</button>
            <a href="#home" class="small">Home</a>
          </div>
        </div>

        <div id="gameRoot" class="game-area game-root"></div>
      </div>
    </main>
  </div>

  <!-- help modal -->
  <div id="helpModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-panel">
      <h3 style="margin-top:0">How it works</h3>
      <p>Select any number to open an empty game panel. Use Back to return to the grid.</p>
      <div style="text-align:right;margin-top:8px"><button id="closeHelp" class="btn">Close</button></div>
    </div>
  </div>
    </section>
    <section data-route="download" data-title="Offline Setup" data-body-class="page-download">
<main class="offline-card">
    <header>
      <h1>Carp Offline Setup</h1>
      <p class="subtitle">We cache everything for you so Carp keeps working without internet.</p>
    </header>

    <section class="offline-section">
      <h2>Offline Toolkit</h2>
      <p class="muted">We are packing every page, style, and game into a handy zip file. Once it lands on your device, open it to browse totally offline.</p>
      <div class="action-row">
        <button id="downloadZip" class="offline-btn primary">Download full site</button>
        <button id="openOffline" class="offline-btn secondary">Open cached site</button>
      </div>
      <p id="statusMessage" class="status-text" data-offline-status>Preparing offline modeâ€¦</p>
    </section>

    <section class="offline-section">
      <h2>Quick tips</h2>
      <ul class="offline-list">
        <li>Use <strong>Open cached site</strong> after the cache finishes to jump right into the offline copy.</li>
        <li>If your browser supports it, choose â€œInstall App / Add to Home Screenâ€ for a one-tap experience.</li>
        <li>Re-run this page any time we add new content so your offline package stays fresh.</li>
      </ul>
    </section>
  </main>
    </section>
    <section data-route="chats" data-title="Private Chats" data-body-class="page-chats">
<div class="chat-shell">
    <header class="chat-header">
      <div>
        <h1>Carp Chats</h1>
        <p class="subtitle">Hang in public rooms or start your own private space with friends.</p>
      </div>
      <div class="profile-chip" id="profileChip">Guest</div>
    </header>

    <div class="chat-layout">
      <aside class="chat-sidebar">
        <section class="chat-section">
          <h2>Public lounges</h2>
          <ul class="room-list" id="publicRoomList"></ul>
        </section>
        <section class="chat-section">
          <h2>Your spaces</h2>
          <ul class="room-list" id="privateRoomList"></ul>
        </section>

        <section class="chat-section">
          <h2>Create a space</h2>
          <form id="createRoomForm" autocomplete="off">
            <label>
              <span>Room name</span>
              <input type="text" id="newRoomName" required maxlength="40" />
            </label>
            <label>
              <span>Room type</span>
              <select id="newRoomType">
                <option value="public">Public</option>
                <option value="private">Private</option>
              </select>
            </label>
            <label>
              <span>Description</span>
              <textarea id="newRoomDesc" rows="2" maxlength="160"></textarea>
            </label>
            <label class="private-only hidden" id="codeLabel">
              <span>Invite code (optional)</span>
              <input type="text" id="newRoomCode" maxlength="12" placeholder="Leave blank for auto code" />
            </label>
            <button type="submit" class="btn primary">Create room</button>
          </form>
        </section>

        <section class="chat-section">
          <h2>Join private</h2>
          <form id="joinRoomForm" autocomplete="off">
            <label>
              <span>Invite code</span>
              <input type="text" id="joinCode" required maxlength="12" />
            </label>
            <button type="submit" class="btn secondary">Join room</button>
            <p class="muted tiny">Ask a friend for the invite code or share one you created.</p>
          </form>
        </section>
      </aside>

      <main class="chat-main">
        <section class="active-room" id="activeRoom" data-room="">
          <header class="room-header">
            <div>
              <h2 id="roomTitle">Pick a room to start chatting</h2>
              <p class="muted" id="roomMeta">No room selected.</p>
            </div>
            <div class="room-actions">
              <span class="room-pill" id="roomTypePill">â€”</span>
              <button class="btn small danger" id="leaveRoomBtn" disabled>Leave room</button>
            </div>
          </header>

          <div class="chat-scroll" id="chatLog">
            <div class="empty-chat">
              <p>Pick a room on the left to see the conversation.</p>
            </div>
          </div>

          <form class="chat-composer" id="messageForm">
            <div class="attach-block">
              <button type="button" class="btn secondary small" id="pickImage">Image</button>
              <input type="file" id="messageFile" accept="image/*" class="hidden" />
              <div class="image-preview hidden" id="imagePreview">
                <img id="imagePreviewImg" alt="Selected attachment preview" />
                <span class="tiny" id="imagePreviewName"></span>
                <button type="button" class="btn tiny danger" id="clearImage">Remove</button>
              </div>
            </div>
            <input type="text" id="messageInput" placeholder="Type a messageâ€¦" autocomplete="off" />
            <button type="submit" class="btn primary" disabled>Send</button>
          </form>
        </section>

        <aside class="member-pane">
          <header>
            <h3>People here</h3>
            <button class="btn tiny" id="refreshMembers">Refresh</button>
          </header>
          <ul class="member-list" id="memberList"></ul>
          <div class="member-note muted">
            Private spaces stay hidden unless someone invites you with the correct code.
          </div>
          <div class="invite-code" id="inviteCodeBlock" hidden>
            <span class="label">Invite code</span>
            <code id="inviteCodeValue"></code>
            <button class="btn tiny" id="copyInvite">Copy</button>
          </div>
        </aside>
      </main>
    </div>
  </div>

  <template id="messageTemplate">
    <li class="message">
      <div class="bubble">
        <header>
          <span class="author"></span>
          <time></time>
        </header>
        <p class="text"></p>
        <div class="image-block hidden">
          <img loading="lazy" alt="Chat attachment" />
          <span class="caption tiny"></span>
        </div>
      </div>
    </li>
  </template>

  <template id="roomTemplate">
    <li>
      <button class="room-btn">
        <div class="room-name"></div>
        <div class="room-desc muted tiny"></div>
      </button>
    </li>
  </template>

  <template id="memberTemplate">
    <li>
      <span class="dot"></span>
      <span class="name"></span>
    </li>
  </template>
    </section>
    <section data-route="carpai" data-title="Carp AI" data-body-class="page-carpai">
<header class="ai-topbar">
    <div class="brand">
      <h1>Carp AI <span class="beta-pill">Beta</span></h1>
      <p class="tagline">Need a pointer? Ask about games, your account, posting, or anything Carp.</p>
    </div>
    <div class="top-actions">
      <nav aria-label="Site navigation">
        <a href="#home" class="chip">home</a>
        <a href="#carpfish" class="chip">games</a>
        <a href="#social" class="chip">social</a>
        <a href="#settings" class="chip">settings</a>
      </nav>
      <button class="btn ghost" id="resetChat" type="button">Reset chat</button>
    </div>
  </header>

  <main class="ai-layout">
    <aside class="ai-sidebar">
      <section class="card prompt-card">
        <h2>Quick prompts</h2>
        <ul class="prompt-list">
          <li><button type="button" class="prompt-btn" data-prompt="Where do I play the CarpFish games?">Where do I play the CarpFish games?</button></li>
          <li><button type="button" class="prompt-btn" data-prompt="How do I start posting to CarpStream?">How do I start posting to CarpStream?</button></li>
          <li><button type="button" class="prompt-btn" data-prompt="Can I update my profile details?">Can I update my profile details?</button></li>
          <li><button type="button" class="prompt-btn" data-prompt="Give me a fun Carp fact.">Give me a fun Carp fact.</button></li>
        </ul>
      </section>
      <section class="card tips-card">
        <h2>AI tips</h2>
        <ul>
          <li>Ask follow-ups to narrow down what you need.</li>
          <li>Use reset if you want a fresh conversation.</li>
          <li>The AI can link you to games, social tools, and settings.</li>
        </ul>
      </section>
    </aside>

    <section class="ai-chat card" aria-live="polite">
      <div id="typingIndicator" class="typing hidden" role="status" aria-live="assertive">Carp AI is thinkingâ€¦</div>
      <ul id="chatLog" class="chat-log"></ul>
      <form id="chatForm" class="chat-form" autocomplete="off">
        <input aria-label="Ask Carp AI" id="chatInput" name="chatInput" placeholder="Ask me somethingâ€¦" required />
        <div class="form-actions">
          <button type="button" class="btn secondary" id="suggestBtn">Give me a suggestion</button>
          <button type="submit" class="btn primary">Send</button>
        </div>
      </form>
    </section>

    <aside class="ai-right">
      <section class="card knowledge-card">
        <h2>What Carp AI knows</h2>
        <dl>
          <dt>Games &amp; entertainment</dt>
          <dd>CarpFish classics, how to play, and new challenges.</dd>
          <dt>Social &amp; sharing</dt>
          <dd>Posting to CarpStream, managing uploads, and staying kind.</dd>
          <dt>Accounts &amp; security</dt>
          <dd>Profile updates, privacy knobs, and general safety.</dd>
          <dt>Fun extras</dt>
          <dd>Fish facts, light jokes, and helpful nudges.</dd>
        </dl>
      </section>
    </aside>
  </main>
    </section>
  </div>
  <script>
(function () {
  const routeMap = {
    '': 'home',
    '/': 'home',
    'home': 'home',
    'index.html': 'home',
    'account.html': 'account',
    'social.html': 'social',
    'settings.html': 'settings',
    'carpfish.html': 'carpfish',
    'download.html': 'download',
    'chats.html': 'chats',
    'carpai.html': 'carpai'
  };

  const sections = Array.from(document.querySelectorAll('[data-route]'));
  const sectionById = new Map(sections.map((el) => [el.dataset.route, el]));
  let currentRoute = null;
  let suppressHash = false;

  function applyRoute(route, push = true) {
    if (!sectionById.has(route)) {
      route = 'home';
    }
    if (currentRoute === route) {
      if (push) updateHash(route);
      return;
    }
    currentRoute = route;
    sections.forEach((el) => {
      if (el.dataset.route === route) {
        el.classList.add('is-active');
        const bodyClass = el.dataset.bodyClass || '';
        document.body.className = ['route-shell', bodyClass].filter(Boolean).join(' ');
        document.title = el.dataset.title || 'carp.edu';
      } else {
        el.classList.remove('is-active');
      }
    });
    if (push) {
      updateHash(route);
    }
  }

  function updateHash(route) {
    suppressHash = true;
    const hashValue = route === 'home' ? 'home' : route;
    if (window.location.hash.replace('#', '') !== hashValue) {
      window.location.hash = hashValue;
    } else {
      suppressHash = false;
    }
    setTimeout(() => { suppressHash = false; }, 0);
  }

  function normalize(href) {
    if (!href) return null;
    if (href.startsWith('#')) {
      const clean = href.slice(1).toLowerCase();
      if (clean === '' || clean === 'home') return 'home';
      return routeMap[clean] || null;
    }
    try {
      const url = new URL(href, window.location.href);
      const path = url.pathname.replace(/^\//, '').toLowerCase();
      if (routeMap[path]) return routeMap[path];
      const hash = url.hash.replace('#', '').toLowerCase();
      if (routeMap[hash]) return routeMap[hash];
    } catch (err) {
      // ignore parse errors
    }
    const cleaned = href.replace(/^\.\//, '').toLowerCase();
    return routeMap[cleaned] || null;
  }

  function rewriteAnchor(anchor) {
    if (!anchor) return;
    if (anchor.target === '_blank' || anchor.hasAttribute('download')) return;
    const original = anchor.getAttribute('data-route-original') || anchor.getAttribute('href');
    if (!original) return;
    const route = normalize(original);
    if (!route) return;
    anchor.setAttribute('data-route-original', original);
    const hash = route === 'home' ? '#home' : '#' + route;
    anchor.setAttribute('href', hash);
  }

  function rewriteAnchors(root) {
    const scope = root || document;
    const anchors = Array.from(scope.querySelectorAll('a[href]'));
    anchors.forEach(rewriteAnchor);
  }

  document.addEventListener('click', (event) => {
    const anchor = event.target.closest('a');
    if (!anchor) return;
    if (anchor.target === '_blank' || anchor.hasAttribute('download')) return;
    const href = anchor.getAttribute('href');
    const route = normalize(href);
    if (!route) return;
    event.preventDefault();
    applyRoute(route);
  });

  window.addEventListener('hashchange', () => {
    if (suppressHash) return;
    const hash = window.location.hash.replace('#', '').toLowerCase();
    const route = routeMap[hash] || hash || 'home';
    applyRoute(route, false);
  });

  rewriteAnchors();

  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType !== Node.ELEMENT_NODE) return;
        if (node.matches && node.matches('a[href]')) {
          rewriteAnchor(node);
        } else {
          rewriteAnchors(node);
        }
      });
    });
  });
  observer.observe(document.body, { childList: true, subtree: true });

  const initialHash = window.location.hash.replace('#', '').toLowerCase();
  const initialRoute = routeMap[initialHash] || initialHash || 'home';
  applyRoute(initialRoute, false);
})();
  </script>
  <script>
(function () {
      try {
        const saved = localStorage.getItem('social.account');
        if (!saved) return;
        const account = JSON.parse(saved);
        if (account && (account.username || account.email)) {
          const banner = document.getElementById('bannerMessage');
          if (banner) banner.textContent = 'have a good time';
        }
      } catch (err) {
        console.error('Account detection failed', err);
      }
    })();
  </script>
  <script>
(function () {
      const storageKeys = {
        account: 'social.account',
        posts: 'social.posts',
        accountsDb: 'social.accounts'
      };

      const accountForm = document.getElementById('accountForm');
      const statusEl = document.getElementById('accountStatus');
      const postForm = document.getElementById('postForm');
      const postList = document.getElementById('postList');
      const clearPostsBtn = document.getElementById('clearPosts');
      const noPostsHint = document.getElementById('noPostsHint');
      const avatarInput = accountForm.querySelector('input[name="avatar"]');
      const profilePreview = document.getElementById('profilePreview');
      const profileAvatar = document.getElementById('profileAvatar');
      const profileName = document.getElementById('profileName');
      const profileEmail = document.getElementById('profileEmail');
      const accountsList = document.getElementById('accountsList');
      const accountsEmpty = document.getElementById('accountsEmpty');
      const refreshAccountsBtn = document.getElementById('refreshAccounts');
      const tabButtons = Array.from(document.querySelectorAll('.tab-link'));
      const tabPanels = Array.from(document.querySelectorAll('.tab-panel'));

      function showTab(name) {
        tabButtons.forEach(button => {
          const isActive = button.dataset.tab === name;
          button.classList.toggle('is-active', isActive);
          button.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
        tabPanels.forEach(panel => {
          const isActive = panel.dataset.tabPanel === name;
          panel.hidden = !isActive;
          panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
        });
      }

      tabButtons.forEach(button => {
        button.addEventListener('click', () => showTab(button.dataset.tab));
      });
      showTab('account');

      function readStorage(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          return JSON.parse(raw);
        } catch (err) {
          console.error('Storage read failed', err);
          return fallback;
        }
      }

      function writeStorage(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (err) {
          console.error('Storage write failed', err);
        }
      }

      function updateAccountsDb(account) {
        const db = readStorage(storageKeys.accountsDb, {});
        db[account.id] = account;
        writeStorage(storageKeys.accountsDb, db);
      }

      function readAccountsDb() {
        return readStorage(storageKeys.accountsDb, {});
      }

      function getAccountId(account) {
        if (!account) return null;
        const key = (account.id || account.email || account.username || '').trim().toLowerCase();
        return key || null;
      }

      function getAccountLabel(account) {
        if (!account) return 'Member';
        const fullName = [account.firstName, account.lastName].filter(Boolean).join(' ').trim();
        return account.username || fullName || account.email || 'Member';
      }

      function togglePostUI(enabled) {
        postForm.hidden = !enabled;
        clearPostsBtn.disabled = !enabled;
        if (enabled) {
          statusEl.classList.remove('error');
          statusEl.textContent = 'Account ready! Start sharing below.';
          if (!postList.children.length) {
            noPostsHint.hidden = false;
            noPostsHint.textContent = 'No posts yet. Share something to get started!';
          }
        }
      }

      function renderProfilePreview(account) {
        if (!profilePreview || !profileName || !profileEmail || !profileAvatar) return;
        if (!account) {
          profilePreview.hidden = true;
          return;
        }
        profileName.textContent = getAccountLabel(account);
        profileEmail.textContent = account.email || '';
        if (account.avatar) {
          profileAvatar.src = account.avatar;
          profileAvatar.hidden = false;
        } else {
          profileAvatar.removeAttribute('src');
          profileAvatar.hidden = true;
        }
        profilePreview.hidden = false;
      }

      function readFileAsDataUrl(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });
      }

      function renderAccountsList() {
        if (!accountsList || !accountsEmpty) return;
        const db = readAccountsDb();
        const accounts = Object.values(db);
        accountsList.innerHTML = '';
        if (!accounts.length) {
          accountsEmpty.hidden = false;
          return;
        }
        accountsEmpty.hidden = true;
        accounts.sort((a, b) => (a.username || '').localeCompare(b.username || ''));
        accounts.forEach(account => {
          const li = document.createElement('li');
          li.className = 'account-entry';

          const avatar = document.createElement('img');
          avatar.className = 'account-entry-avatar';
          if (account.avatar) {
            avatar.src = account.avatar;
            avatar.alt = account.username || 'Account avatar';
          } else {
            avatar.src = '';
            avatar.alt = '';
            avatar.classList.add('placeholder');
          }

          const body = document.createElement('div');
          body.className = 'account-entry-body';

          const title = document.createElement('div');
          title.className = 'account-entry-name';
          title.textContent = getAccountLabel(account);

          const meta = document.createElement('div');
          meta.className = 'account-entry-meta';
          meta.textContent = [account.username, account.email].filter(Boolean).join(' â€¢ ');

          body.appendChild(title);
          body.appendChild(meta);
          li.appendChild(avatar);
          li.appendChild(body);
          accountsList.appendChild(li);
        });
      }

      function renderPosts(posts) {
        postList.innerHTML = '';
        const account = readStorage(storageKeys.account, null);
        const accountId = getAccountId(account);

        if (!accountId) {
          noPostsHint.hidden = false;
          noPostsHint.textContent = 'Create an account to manage your posts.';
          clearPostsBtn.disabled = true;
          return;
        }

        const entries = posts
          .map((post, idx) => ({ post, idx }))
          .filter(entry => (entry.post.ownerId || accountId) === accountId);

        if (!entries.length) {
          noPostsHint.hidden = false;
          clearPostsBtn.disabled = true;
          return;
        }

        noPostsHint.hidden = true;
        clearPostsBtn.disabled = false;

        entries.forEach(({ post, idx }) => {
          const item = document.createElement('li');
          item.className = 'post-item';

          const header = document.createElement('div');
          header.className = 'post-meta';
          const ownerLabel = post.ownerName || getAccountLabel(account);
          header.textContent = new Date(post.createdAt).toLocaleString() + ' â€¢ ' + ownerLabel;

          const body = document.createElement('p');
          body.className = 'post-body';
          body.textContent = post.body;

          const actions = document.createElement('div');
          actions.className = 'post-actions';

          const likeBtn = document.createElement('button');
          likeBtn.type = 'button';
          likeBtn.className = 'btn tiny';
          likeBtn.textContent = '\u2764\uFE0F ' + (post.likes || 0);
          likeBtn.addEventListener('click', () => {
            posts[idx].likes = (posts[idx].likes || 0) + 1;
            writeStorage(storageKeys.posts, posts);
            renderPosts(posts);
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.className = 'btn tiny danger';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            posts.splice(idx, 1);
            writeStorage(storageKeys.posts, posts);
            renderPosts(posts);
          });

          actions.appendChild(likeBtn);
          actions.appendChild(deleteBtn);

          item.appendChild(header);
          item.appendChild(body);
          item.appendChild(actions);
          postList.appendChild(item);
        });
      }

      function initAccount() {
        let savedAccount = readStorage(storageKeys.account, null);
        const accountId = getAccountId(savedAccount);

        if (savedAccount && accountId && !savedAccount.id) {
          savedAccount.id = accountId;
          writeStorage(storageKeys.account, savedAccount);
        }

        if (savedAccount) {
          accountForm.firstName.value = savedAccount.firstName || '';
          accountForm.lastName.value = savedAccount.lastName || '';
          accountForm.username.value = savedAccount.username || '';
          accountForm.email.value = savedAccount.email || '';
          statusEl.textContent = 'Welcome back, ' + getAccountLabel(savedAccount) + '!';
          togglePostUI(true);
          updateAccountsDb(savedAccount);
          renderProfilePreview(savedAccount);
        } else {
          togglePostUI(false);
          renderProfilePreview(null);
        }

        const savedPosts = readStorage(storageKeys.posts, []);
        if (accountId) {
          let mutated = false;
          const savedLabel = savedAccount ? getAccountLabel(savedAccount) : null;
          const savedAvatar = savedAccount && savedAccount.avatar ? savedAccount.avatar : null;
          savedPosts.forEach(post => {
            if (!post.ownerId) {
              post.ownerId = accountId;
              mutated = true;
            }
            if (!post.ownerName && savedLabel) {
              post.ownerName = savedLabel;
              mutated = true;
            }
            if (!post.ownerAvatar && savedAvatar) {
              post.ownerAvatar = savedAvatar;
              mutated = true;
            }
          });
          if (mutated) writeStorage(storageKeys.posts, savedPosts);
        }
        renderPosts(savedPosts);
        if (savedAccount && savedPosts.length) noPostsHint.hidden = true;
        renderAccountsList();
      }

      accountForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const formData = new FormData(accountForm);
        const account = {
          firstName: formData.get('firstName').trim(),
          lastName: formData.get('lastName').trim(),
          username: formData.get('username').trim(),
          email: formData.get('email').trim()
        };
        account.id = getAccountId(account);

        if (!account.firstName || !account.lastName || !account.username || !account.email || !account.id) {
          statusEl.textContent = 'Please fill in every field to continue.';
          statusEl.classList.add('error');
          return;
        }

        const existingAccount = readStorage(storageKeys.account, null);
        let avatar = existingAccount && existingAccount.avatar ? existingAccount.avatar : null;

        if (avatarInput && avatarInput.files && avatarInput.files[0]) {
          try {
            avatar = await readFileAsDataUrl(avatarInput.files[0]);
          } catch (err) {
            console.error('Avatar read failed', err);
            statusEl.textContent = 'Could not read the selected profile picture.';
            statusEl.classList.add('error');
            return;
          }
        }
        if (avatarInput) avatarInput.value = '';
        account.avatar = avatar;

        statusEl.classList.remove('error');
        writeStorage(storageKeys.account, account);
        updateAccountsDb(account);
        togglePostUI(true);
        statusEl.textContent = 'Account saved. Hi, ' + getAccountLabel(account) + '!';
        renderProfilePreview(account);
        renderPosts(readStorage(storageKeys.posts, []));
        renderAccountsList();
      });

      postForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const account = readStorage(storageKeys.account, null);
        const accountId = getAccountId(account);
        if (!accountId) {
          statusEl.textContent = 'Create an account before posting.';
          statusEl.classList.add('error');
          return;
        }

        statusEl.classList.remove('error');

        const textarea = postForm.postBody;
        const body = textarea.value.trim();
        if (!body) return;

        const posts = readStorage(storageKeys.posts, []);
        posts.unshift({
          id: 'account-post-' + Date.now(),
          body,
          createdAt: Date.now(),
          likes: 0,
          ownerId: accountId,
          ownerName: getAccountLabel(account),
          ownerAvatar: account && account.avatar ? account.avatar : null
        });
        writeStorage(storageKeys.posts, posts);
        textarea.value = '';
        renderPosts(posts);
      });

      clearPostsBtn.addEventListener('click', () => {
        const account = readStorage(storageKeys.account, null);
        const accountId = getAccountId(account);
        if (!accountId) return;
        if (!confirm('Remove all of your saved posts?')) return;
        const posts = readStorage(storageKeys.posts, []);
        const remaining = posts.filter(post => (post.ownerId || accountId) !== accountId);
        writeStorage(storageKeys.posts, remaining);
        renderPosts(remaining);
      });

      if (refreshAccountsBtn) {
        refreshAccountsBtn.addEventListener('click', () => renderAccountsList());
      }

      initAccount();
    })();
  </script>
  <script>
(function () {
    const listView = document.getElementById('listView');
    const gameView = document.getElementById('gameView');
    const gameRoot = document.getElementById('gameRoot');
    const backBtn = document.getElementById('backBtn');
    const restartBtn = document.getElementById('restartBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const closeHelp = document.getElementById('closeHelp');
    const gameTitle = document.getElementById('gameTitle');
    const scorePill = document.getElementById('scorePill');

    // Prevent browser dialogs and messages
    window.addEventListener('error', (e) => {
        e.preventDefault();
        console.error(e.message);
        return true;
    });

    window.onbeforeunload = null;
    window.addEventListener('beforeunload', (e) => {
        e.preventDefault();
        e.returnValue = '';
        return '';
    });

    let current = null; // {cleanup, restart}
    let currentName = null;

    function showList() {
        if (current && current.cleanup) { try { current.cleanup(); } catch (e) { console.error(e); } current = null; }
        currentName = null;
        gameRoot.innerHTML = '';
        gameView.style.display = 'none';
        listView.style.display = '';
        gameTitle.textContent = '';
        scorePill.textContent = '';
        renderGameList(); // Re-render the game list when returning to it
    }
    function showGame(name, builder) {
        listView.style.display = 'none';
        gameView.style.display = '';
        gameRoot.innerHTML = '';
        gameTitle.textContent = name;
        scorePill.textContent = '';
        if (current && current.cleanup) { try { current.cleanup(); } catch (e) { console.error(e); } current = null; }

        // Add game over display helper
        const displayGameOver = (message, score) => {
            const overlay = document.createElement('div');
            overlay.className = 'game-over';
            overlay.innerHTML = `
          <div>Game Over!</div>
          <div class="score">${message}: ${score}</div>
          <button class="retry">Play Again</button>
        `;
            gameRoot.appendChild(overlay);
            const retryBtn = overlay.querySelector('.retry');
            retryBtn.addEventListener('click', () => {
                overlay.remove();
                if (current && current.restart) current.restart();
            });
        };

        const res = builder(gameRoot, (txt) => { scorePill.textContent = txt; }, displayGameOver);
        current = res || null;
        currentName = name;

        // Prevent browser from showing "leave page" dialog
        window.onbeforeunload = null;
    }

    // Prevent browser dialogs globally
    window.addEventListener('beforeunload', (e) => {
        e.preventDefault();
        e.returnValue = '';
        return '';
    });

    backBtn.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default behavior
        showList();
    });
    refreshBtn.addEventListener('click', () => location.reload());
    restartBtn.addEventListener('click', () => {
        if (current && current.restart) {
            try {
                current.restart();
            } catch (e) {
                console.error('Error restarting game:', e);
            }
        }
    });
    helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
    closeHelp.addEventListener('click', () => helpModal.classList.add('hidden'));

    restartBtn.addEventListener('click', () => { if (current && current.restart) current.restart(); else location.reload(); });

    const PLACEHOLDER_COUNT = 100;

    // Placeholder entries to keep the grid size consistent
    const GAMES = Array.from({ length: PLACEHOLDER_COUNT }, (_, index) => ({
        id: `placeholder-${index + 1}`
    }));

    let placeholderMode = true;

    function registerGame(id, title, desc, builder) {
        if (placeholderMode) return;
        GAMES.push({ id, title, desc, builder });
    }

    // Register all games
    registerGame('2048', '2048', 'Merge tiles to reach 2048', build2048);
    registerGame('snake', 'Snake', 'Classic snake game', buildSnake);
    registerGame('breakout', 'Breakout', 'Break all the bricks', buildBreakout);
    registerGame('memory', 'Memory Match', 'Find matching pairs', buildMemory);
    registerGame('whack', 'Whack-a-Mole', 'Quick reflexes game', buildWhack);
    registerGame('flappy', 'Flappy', 'Navigate through pipes', buildFlappy);
    registerGame('bitlife', 'Life Sim', 'Life simulation game', buildLifeSim);
    registerGame('drive', 'Drive Mad', 'Endless driving game', buildDrive);
    registerGame('basket', 'Basket Random', 'Chaotic 2v2 basketball duels', buildBasketRandom);
    registerGame('ancient', 'Ancient Beast', 'Creature battle strategy', buildAncient);
    registerGame('craft', 'Block Craft', 'Creative building game', buildCraft);
    registerGame('runner', 'Temple Run', 'Endless runner game', buildRunner);
    registerGame('candy', 'Candy Match', 'Match-3 puzzle game', buildCandy);
    registerGame('pacman', 'Maze Chase', 'Collect dots, avoid ghosts', buildPacman);
    registerGame('tetris', 'Block Drop', 'Classic tetris game', buildTetris);
    registerGame('words', 'Word Quest', 'Word puzzle game', buildWords);
    registerGame('defense', 'Tower Defense', 'Strategic tower placement game', buildDefense);
    registerGame('doodle', 'Doodle Jump', 'Jump your way to the top', buildDoodle);
    registerGame('chess', 'Mini Chess', 'Classic chess game vs AI', buildChess);
    registerGame('solitaire', 'Solitaire', 'Classic card game', buildSolitaire);
    registerGame('racer', 'Speed Racer', '3D racing game with multiple tracks', buildRace);
    registerGame('fruit', 'Fruit Slice', 'Slice fruits, avoid bombs', buildFruit);
    registerGame('tower', 'Tower Stack', 'Stack blocks to build tower', buildTower);
    registerGame('bubble', 'Bubble Shooter', 'Match 3 or more bubbles', buildBubble);
    registerGame('piano', 'Piano Tiles', 'Tap the black tiles', buildPiano);

    // Initialize game list
    function renderGameList() {
        const tiles = GAMES.map(() => `
              <div class="tile tile-empty" aria-hidden="true"></div>
            `).join('');

        listView.innerHTML = `
        <div class="container">
          <div class="grid">
            ${tiles}
          </div>
        </div>
      `;
    }

    // Initial render
    renderGameList();

    // ---------- 1) 2048 (improved) ----------
    function build2048(container, setScore, displayGameOver) {
        container.innerHTML = `
        <div class="g2048-wrapper" style="max-width:640px;margin:0 auto">
          <div class="g2048-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div class="g2048-title" style="font-weight:900;font-size:20px">2048</div>
            <div class="g2048-help" style="color:var(--muted);font-size:13px">Swipe or use arrow keys</div>
          </div>
          <div class="g2048-meta" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div class="g2048-pill" id="g2048-score" style="background:rgba(255,255,255,0.06);padding:6px 12px;border-radius:999px;font-size:13px">Score: 0</div>
            <button class="g2048-new" id="g2048-new" style="padding:6px 16px;border-radius:999px;border:none;background:#1c7ed6;color:#fff;font-weight:600;cursor:pointer">New Game</button>
          </div>
          <div class="g2048-board" id="g2048-board" role="grid" aria-label="2048 board"></div>
        </div>
      `;

        const board = container.querySelector('#g2048-board');
        const scorePill = container.querySelector('#g2048-score');
        const newBtn = container.querySelector('#g2048-new');
        const SIZE = 4;

        let grid = [];
        let score = 0;
        let gameActive = true;
        let pendingWin = false;
        let lastCreated = null;

        const tileColors = {
            0: '#102032',
            2: '#eae0d5',
            4: '#e7d4bc',
            8: '#f4a259',
            16: '#f06b45',
            32: '#f34235',
            64: '#e84a27',
            128: '#cdb24f',
            256: '#c5a63f',
            512: '#bf9932',
            1024: '#b98d24',
            2048: '#b28018'
        };

        const tiles = [];
        for (let r = 0; r < SIZE; r++) {
            const row = [];
            for (let c = 0; c < SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'g2048-cell';
                cell.setAttribute('role', 'gridcell');
                row.push(cell);
                board.appendChild(cell);
            }
            tiles.push(row);
        }

        function formatScore(value) {
            if (value < 1000) return value.toString();
            if (value < 1000000) return (value / 1000).toFixed(value % 1000 === 0 ? 0 : 1) + 'K';
            return (value / 1000000).toFixed(value % 1000000 === 0 ? 0 : 1) + 'M';
        }

        function updateScore(delta = 0) {
            score += delta;
            scorePill.textContent = 'Score: ' + formatScore(score);
            setScore('Score: ' + score);
        }

        function randomEmptyCell() {
            const empties = [];
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    if (grid[r][c] === 0) empties.push({ r, c });
                }
            }
            if (!empties.length) return null;
            return empties[Math.floor(Math.random() * empties.length)];
        }

        function spawnTile() {
            const spot = randomEmptyCell();
            if (!spot) return false;
            grid[spot.r][spot.c] = Math.random() < 0.9 ? 2 : 4;
            lastCreated = spot;
            return true;
        }

        function render() {
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const value = grid[r][c];
                    const tile = tiles[r][c];
                    tile.textContent = value ? value : '';
                    tile.dataset.value = value;
                    tile.style.background = tileColors[value] || '#5d6270';
                    tile.style.color = value <= 4 ? '#1d2330' : '#f6f7fa';
                    tile.classList.toggle('g2048-new', !!lastCreated && lastCreated.r === r && lastCreated.c === c);
                }
            }
            lastCreated = null;
        }

        function cloneGrid() {
            return grid.map(row => row.slice());
        }

        function rotate(times) {
            // rotate grid clockwise `times` times
            for (let t = 0; t < times; t++) {
                const next = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
                for (let r = 0; r < SIZE; r++) {
                    for (let c = 0; c < SIZE; c++) {
                        next[c][SIZE - 1 - r] = grid[r][c];
                    }
                }
                grid = next;
            }
        }

        function compressRow(row) {
            const filtered = row.filter(v => v !== 0);
            for (let i = 0; i < filtered.length - 1; i++) {
                if (filtered[i] === filtered[i + 1]) {
                    filtered[i] *= 2;
                    updateScore(filtered[i]);
                    filtered.splice(i + 1, 1);
                }
            }
            while (filtered.length < SIZE) filtered.push(0);
            return filtered;
        }

        function moveLeft() {
            let moved = false;
            for (let r = 0; r < SIZE; r++) {
                const nextRow = compressRow(grid[r]);
                for (let c = 0; c < SIZE; c++) {
                    if (grid[r][c] !== nextRow[c]) moved = true;
                }
                grid[r] = nextRow;
            }
            return moved;
        }

        function move(direction) {
            if (!gameActive) return;
            const previous = cloneGrid();
            if (direction === 'right') rotate(2);
            if (direction === 'up') rotate(3);
            if (direction === 'down') rotate(1);

            const moved = moveLeft();

            if (direction === 'right') rotate(2);
            if (direction === 'up') rotate(1);
            if (direction === 'down') rotate(3);

            if (!moved) {
                grid = previous;
                return;
            }

            spawnTile();
            render();
            checkGameState();
        }

        function hasMoves() {
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const value = grid[r][c];
                    if (value === 0) return true;
                    if (c < SIZE - 1 && grid[r][c + 1] === value) return true;
                    if (r < SIZE - 1 && grid[r + 1][c] === value) return true;
                }
            }
            return false;
        }

        function checkGameState() {
            if (!pendingWin && grid.some(row => row.includes(2048))) {
                pendingWin = true;
                gameActive = false;
                if (displayGameOver) displayGameOver('You win', score);
                return;
            }
            if (!hasMoves()) {
                gameActive = false;
                if (displayGameOver) displayGameOver('Score', score);
            }
        }

        function handleKey(e) {
            if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) return;
            e.preventDefault();
            if (!gameActive) return;
            if (e.key === 'ArrowLeft') move('left');
            if (e.key === 'ArrowRight') move('right');
            if (e.key === 'ArrowUp') move('up');
            if (e.key === 'ArrowDown') move('down');
        }

        let touchStart = null;
        function onTouchStart(e) {
            const touch = e.touches[0];
            touchStart = { x: touch.clientX, y: touch.clientY };
        }

        function onTouchEnd(e) {
            if (!touchStart || !gameActive) return;
            const touch = e.changedTouches[0];
            const dx = touch.clientX - touchStart.x;
            const dy = touch.clientY - touchStart.y;
            touchStart = null;
            if (Math.max(Math.abs(dx), Math.abs(dy)) < 30) return;
            if (Math.abs(dx) > Math.abs(dy)) {
                move(dx > 0 ? 'right' : 'left');
            } else {
                move(dy > 0 ? 'down' : 'up');
            }
        }

        function newGame() {
            grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
            score = 0;
            gameActive = true;
            pendingWin = false;
            lastCreated = null;
            updateScore(0);
            spawnTile();
            spawnTile();
            render();
        }

        function handleNewGame() {
            if (displayGameOver) {
                const overlay = container.querySelector('.game-over');
                if (overlay) overlay.remove();
            }
            newGame();
        }

        window.addEventListener('keydown', handleKey);
        board.addEventListener('touchstart', onTouchStart, { passive: true });
        board.addEventListener('touchend', onTouchEnd, { passive: true });
        newBtn.addEventListener('click', handleNewGame);

        newGame();

        return {
            cleanup() {
                window.removeEventListener('keydown', handleKey);
                board.removeEventListener('touchstart', onTouchStart);
                board.removeEventListener('touchend', onTouchEnd);
                newBtn.removeEventListener('click', handleNewGame);
            },
            restart() {
                handleNewGame();
            }
        };
    }

    // ---------- 2) Snake (smoother) ----------
    function buildSnake(container, setScore, displayGameOver) {
        container.innerHTML = `
        <div class="snake-wrapper" style="display:flex;flex-direction:column;align-items:center">
          <div class="snake-header" style="display:flex;flex-direction:column;align-items:center;gap:4px">
            <div class="snake-title" style="font-weight:900;font-size:20px">Neon Snake</div>
            <div class="snake-hint" style="color:var(--muted);font-size:13px">Arrow keys or swipe Â· Space to pause</div>
          </div>
          <canvas id="snake-canvas" width="420" height="420" class="snake-canvas" style="background:#071827;border-radius:10px;margin-top:12px"></canvas>
        </div>
      `;

        const canvas = container.querySelector('#snake-canvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 18;
        const cols = Math.floor(canvas.width / cellSize);
        const rows = Math.floor(canvas.height / cellSize);

        let snake = [];
        let direction = { x: 1, y: 0 };
        let queuedDirection = { x: 1, y: 0 };
        let apple = null;
        let raf = null;
        let running = false;
        let paused = false;
        let lastTick = 0;
        let tickInterval = 140;
        let score = 0;

        const gradientCache = new Map();

        function gradientFor(segmentIndex) {
            if (gradientCache.has(segmentIndex)) return gradientCache.get(segmentIndex);
            const gradient = ctx.createLinearGradient(0, 0, cellSize, cellSize);
            const t = Math.max(0.2, 1 - segmentIndex * 0.05);
            gradient.addColorStop(0, `rgba(130,255,195,${t})`);
            gradient.addColorStop(1, `rgba(32,220,130,${t})`);
            gradientCache.set(segmentIndex, gradient);
            return gradient;
        }

        function centerPoint() {
            return {
                x: Math.floor(cols / 2),
                y: Math.floor(rows / 2)
            };
        }

        function spawnApple() {
            const available = [];
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    if (!snake.some(segment => segment.x === x && segment.y === y)) {
                        available.push({ x, y });
                    }
                }
            }
            if (!available.length) {
                apple = null;
                return;
            }
            apple = available[Math.floor(Math.random() * available.length)];
        }

        function resetState() {
            snake = [centerPoint()];
            direction = { x: 1, y: 0 };
            queuedDirection = { x: 1, y: 0 };
            score = 0;
            tickInterval = 140;
            running = true;
            paused = false;
            lastTick = 0;
            setScore('Score: 0');
            spawnApple();
            draw();
            scheduleLoop();
        }

        function scheduleLoop() {
            if (raf) cancelAnimationFrame(raf);
            raf = requestAnimationFrame(loop);
        }

        function loop(timestamp) {
            if (!running) return;
            if (paused) {
                raf = requestAnimationFrame(loop);
                return;
            }

            if (!lastTick) lastTick = timestamp;
            const elapsed = timestamp - lastTick;

            if (elapsed >= tickInterval) {
                lastTick = timestamp;
                step();
                draw();
            }

            raf = requestAnimationFrame(loop);
        }

        function step() {
            direction = queuedDirection;
            const head = {
                x: (snake[0].x + direction.x + cols) % cols,
                y: (snake[0].y + direction.y + rows) % rows
            };

            const eating = apple && apple.x === head.x && apple.y === head.y;
            if (!eating) snake.pop();

            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                endGame();
                return;
            }

            snake.unshift(head);

            if (eating) {
                score += 10;
                setScore('Score: ' + score);
                if (tickInterval > 70) tickInterval -= 2;
                spawnApple();
                if (!apple && displayGameOver) {
                    running = false;
                    displayGameOver('Perfect score', score);
                }
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#062037');
            gradient.addColorStop(1, '#04101f');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellSize, 0);
                ctx.lineTo(x * cellSize, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellSize);
                ctx.lineTo(canvas.width, y * cellSize);
                ctx.stroke();
            }
        }

        function drawRoundedRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function drawSnake() {
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(46, 255, 158, 0.4)';
            snake.forEach((segment, idx) => {
                ctx.fillStyle = gradientFor(idx);
                const x = segment.x * cellSize + 2;
                const y = segment.y * cellSize + 2;
                const size = cellSize - 4;
                drawRoundedRect(x, y, size, size, 6);
                ctx.fill();

                if (idx === 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.18)';
                    ctx.beginPath();
                    ctx.arc(x + size * 0.3, y + size * 0.35, 3, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.7, y + size * 0.35, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }

        function drawApple() {
            if (!apple) return;
            ctx.save();
            ctx.shadowColor = 'rgba(255,94,91,0.5)';
            ctx.shadowBlur = 18;
            const x = apple.x * cellSize + cellSize / 2;
            const y = apple.y * cellSize + cellSize / 2;
            ctx.beginPath();
            ctx.fillStyle = '#ff5e5b';
            ctx.arc(x, y, cellSize / 2.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = '#4db06e';
            ctx.ellipse(x + 2, y - cellSize / 2.6, cellSize / 5, cellSize / 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawState() {
            if (!running) return;
            ctx.fillStyle = 'rgba(5,12,20,0.6)';
            ctx.fillRect(0, canvas.height - 28, canvas.width, 28);
            ctx.fillStyle = '#9ecff4';
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Length: ' + snake.length, 12, canvas.height - 10);
            ctx.textAlign = 'right';
            const cellsPerSecond = 1000 / tickInterval;
            const statusText = paused ? 'Paused' : 'Speed: ' + cellsPerSecond.toFixed(1) + ' cells/s';
            ctx.fillText(statusText, canvas.width - 12, canvas.height - 10);
        }

        function draw() {
            drawBackground();
            drawApple();
            drawSnake();
            drawState();
        }

        function endGame() {
            running = false;
            cancelAnimationFrame(raf);
            if (displayGameOver) displayGameOver('Score', score);
        }

        function queueDirection(next) {
            if (!running || paused) return;
            const isOpposite = next.x === -direction.x && next.y === -direction.y;
            if (isOpposite) return;
            queuedDirection = next;
        }

        function handleKey(event) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(event.key)) {
                event.preventDefault();
            }
            if (!running) return;
            switch (event.key) {
                case 'ArrowUp': queueDirection({ x: 0, y: -1 }); break;
                case 'ArrowDown': queueDirection({ x: 0, y: 1 }); break;
                case 'ArrowLeft': queueDirection({ x: -1, y: 0 }); break;
                case 'ArrowRight': queueDirection({ x: 1, y: 0 }); break;
                case ' ':
                    paused = !paused;
                    if (!paused) {
                        lastTick = performance.now();
                    }
                    break;
                default:
            }
        }

        let swipeOrigin = null;
        function onTouchStart(event) {
            const touch = event.touches[0];
            swipeOrigin = { x: touch.clientX, y: touch.clientY };
        }

        function onTouchEnd(event) {
            if (!swipeOrigin || !running) return;
            const touch = event.changedTouches[0];
            const dx = touch.clientX - swipeOrigin.x;
            const dy = touch.clientY - swipeOrigin.y;
            swipeOrigin = null;

            if (Math.abs(dx) < 25 && Math.abs(dy) < 25) {
                paused = !paused;
                if (!paused) lastTick = performance.now();
                return;
            }

            if (Math.abs(dx) > Math.abs(dy)) {
                queueDirection(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
            } else {
                queueDirection(dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 });
            }
        }

        function teardown() {
            cancelAnimationFrame(raf);
            window.removeEventListener('keydown', handleKey);
            canvas.removeEventListener('touchstart', onTouchStart);
            canvas.removeEventListener('touchend', onTouchEnd);
        }

        window.addEventListener('keydown', handleKey);
        canvas.addEventListener('touchstart', onTouchStart, { passive: true });
        canvas.addEventListener('touchend', onTouchEnd, { passive: true });

        resetState();

        return {
            cleanup: teardown,
            restart() {
                teardown();
                window.addEventListener('keydown', handleKey);
                canvas.addEventListener('touchstart', onTouchStart, { passive: true });
                canvas.addEventListener('touchend', onTouchEnd, { passive: true });
                resetState();
            }
        };
    }

    // ---------- 3) Breakout (improved) ----------
    function buildBreakout(container, setScore, displayGameOver) {
        container.innerHTML = `
        <div class="breakout-wrapper" style="display:flex;flex-direction:column;align-items:center">
          <div class="breakout-header" style="display:flex;flex-direction:column;align-items:center;gap:4px">
            <div class="breakout-title" style="font-weight:900;font-size:20px">Pulse Breakout</div>
            <div class="breakout-hint" style="color:var(--muted);font-size:13px">Mouse, touch or arrow keys to move</div>
          </div>
          <canvas id="breakout-canvas" width="640" height="380" class="breakout-canvas" style="background:#071827;border-radius:10px;margin-top:12px"></canvas>
        </div>
      `;

        const canvas = container.querySelector('#breakout-canvas');
        const ctx = canvas.getContext('2d');

        const paddle = {
            width: 120,
            height: 14,
            speed: 6,
            x: canvas.width / 2 - 60
        };

        const ball = {
            radius: 8,
            x: canvas.width / 2,
            y: canvas.height - 80,
            vx: 4,
            vy: -5,
            launched: false
        };

        const state = {
            level: 1,
            score: 0,
            lives: 3,
            running: true,
            bricks: []
        };

        let raf = null;
        let leftPressed = false;
        let rightPressed = false;

        function updateScorePill() {
            setScore('Score: ' + state.score + ' | Lives: ' + state.lives + ' | Level: ' + state.level);
        }

        function resetBall() {
            ball.x = paddle.x + paddle.width / 2;
            ball.y = canvas.height - 80;
            ball.vx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.min(state.level, 3));
            ball.vy = -5 - Math.min(state.level, 4);
            ball.launched = false;
        }

        function createLevel(level) {
            const rows = 4 + Math.min(level, 4);
            const cols = 9;
            const padding = 16;
            const marginTop = 40;
            const brickWidth = (canvas.width - padding * (cols + 1)) / cols;
            const brickHeight = 22;
            const palette = ['#ff6b6b', '#ffd93d', '#6ef6ff', '#8aff80', '#d890ff', '#ffa9e7'];

            state.bricks = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    state.bricks.push({
                        x: padding + col * (brickWidth + padding),
                        y: marginTop + row * (brickHeight + 10),
                        width: brickWidth,
                        height: brickHeight,
                        hp: 1 + Math.floor(level / 2),
                        color: palette[(row + level) % palette.length]
                    });
                }
            }

            updateScorePill();
        }

        function launchBall() {
            if (!ball.launched) {
                ball.launched = true;
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#021a2b');
            gradient.addColorStop(1, '#061322');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawRoundedRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.save();
            const grad = ctx.createLinearGradient(paddle.x, 0, paddle.x + paddle.width, 0);
            grad.addColorStop(0, '#4dd0e1');
            grad.addColorStop(1, '#00bcd4');
            ctx.fillStyle = grad;
            ctx.shadowColor = 'rgba(0,188,212,0.4)';
            ctx.shadowBlur = 15;
            drawRoundedRect(paddle.x, canvas.height - paddle.height - 18, paddle.width, paddle.height, 8);
            ctx.fill();
            ctx.restore();
        }

        function drawBall() {
            ctx.save();
            ctx.shadowColor = 'rgba(255,214,79,0.6)';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffd54f';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawBricks() {
            state.bricks.forEach(brick => {
                ctx.save();
                ctx.fillStyle = brick.color;
                ctx.shadowColor = 'rgba(0,0,0,0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 4;
                drawRoundedRect(brick.x, brick.y, brick.width, brick.height, 6);
                ctx.fill();
                ctx.restore();

                if (brick.hp > 1) {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(brick.x + 6, brick.y + 6, brick.width - 12, 6);
                }
            });
        }

        function drawOverlay() {
            if (!state.running || state.bricks.length) return;
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#9ac7ff';
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('All bricks cleared! Press space to continue.', canvas.width / 2, canvas.height / 2);
        }

        function draw() {
            drawBackground();
            drawBricks();
            drawPaddle();
            drawBall();
            drawOverlay();
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function handleWallCollisions() {
            if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.vx *= -1;
            }
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.vx *= -1;
            }
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.vy *= -1;
            }
        }

        function handlePaddleCollision() {
            const paddleTop = canvas.height - paddle.height - 18;
            if (ball.y + ball.radius >= paddleTop &&
                ball.y + ball.radius <= paddleTop + paddle.height &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width &&
                ball.vy > 0) {
                const collisionPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                const bounceAngle = collisionPoint * (Math.PI / 3); // 60 degrees
                const speed = Math.hypot(ball.vx, ball.vy) * 1.03;
                ball.vx = speed * Math.sin(bounceAngle);
                ball.vy = -Math.abs(speed * Math.cos(bounceAngle));
            }
        }

        function handleBrickCollisions() {
            for (let i = 0; i < state.bricks.length; i++) {
                const brick = state.bricks[i];
                if (ball.x + ball.radius < brick.x ||
                    ball.x - ball.radius > brick.x + brick.width ||
                    ball.y + ball.radius < brick.y ||
                    ball.y - ball.radius > brick.y + brick.height) {
                    continue;
                }

                const prevX = ball.x - ball.vx;
                const prevY = ball.y - ball.vy;
                const collidedFromLeft = prevX + ball.radius <= brick.x;
                const collidedFromRight = prevX - ball.radius >= brick.x + brick.width;
                const collidedFromTop = prevY + ball.radius <= brick.y;
                const collidedFromBottom = prevY - ball.radius >= brick.y + brick.height;

                if (collidedFromLeft || collidedFromRight) {
                    ball.vx *= -1;
                } else if (collidedFromTop || collidedFromBottom) {
                    ball.vy *= -1;
                } else {
                    ball.vy *= -1;
                }

                brick.hp -= 1;
                state.score += 20;
                if (brick.hp <= 0) state.bricks.splice(i, 1);
                updateScorePill();
                break;
            }
        }

        function loseLife() {
            state.lives -= 1;
            updateScorePill();
            if (state.lives <= 0) {
                state.running = false;
                if (displayGameOver) displayGameOver('Score', state.score);
                return;
            }
            resetBall();
        }

        function nextLevel() {
            state.level += 1;
            state.score += 200;
            createLevel(state.level);
            resetBall();
            updateScorePill();
        }

        function update(delta) {
            if (!state.running) return;

            if (!ball.launched) {
                ball.x = paddle.x + paddle.width / 2;
                ball.y = canvas.height - paddle.height - 18 - ball.radius;
            } else {
                ball.x += ball.vx;
                ball.y += ball.vy;
            }

            if (leftPressed) paddle.x -= paddle.speed;
            if (rightPressed) paddle.x += paddle.speed;
            paddle.x = clamp(paddle.x, 12, canvas.width - paddle.width - 12);

            handleWallCollisions();
            handlePaddleCollision();
            handleBrickCollisions();

            if (ball.y - ball.radius > canvas.height + 30) {
                loseLife();
            }

            if (state.bricks.length === 0 && state.running) {
                nextLevel();
            }
        }

        let lastTime = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const delta = timestamp - lastTime;
            lastTime = timestamp;

            update(delta);
            draw();

            if (state.running || state.bricks.length === 0) {
                raf = requestAnimationFrame(loop);
            }
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mx = event.clientX - rect.left;
            paddle.x = clamp(mx - paddle.width / 2, 12, canvas.width - paddle.width - 12);
        }

        function handleTouchMove(event) {
            if (!event.touches.length) return;
            const rect = canvas.getBoundingClientRect();
            const mx = event.touches[0].clientX - rect.left;
            paddle.x = clamp(mx - paddle.width / 2, 12, canvas.width - paddle.width - 12);
        }

        function handleKeyDown(event) {
            if (event.key === 'ArrowLeft') {
                leftPressed = true;
                event.preventDefault();
            }
            if (event.key === 'ArrowRight') {
                rightPressed = true;
                event.preventDefault();
            }
            if (event.key === ' ' || event.key === 'Spacebar') {
                event.preventDefault();
                launchBall();
            }
        }

        function handleKeyUp(event) {
            if (event.key === 'ArrowLeft') {
                leftPressed = false;
                event.preventDefault();
            }
            if (event.key === 'ArrowRight') {
                rightPressed = false;
                event.preventDefault();
            }
        }

        function handleClick() {
            launchBall();
        }

        function attachEvents() {
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
            canvas.addEventListener('click', handleClick);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        }

        function detachEvents() {
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('touchmove', handleTouchMove);
            canvas.removeEventListener('click', handleClick);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        }

        function start() {
            state.level = 1;
            state.score = 0;
            state.lives = 3;
            state.running = true;
            leftPressed = false;
            rightPressed = false;
            createLevel(state.level);
            resetBall();
            updateScorePill();
            if (raf) cancelAnimationFrame(raf);
            lastTime = 0;
            raf = requestAnimationFrame(loop);
        }

        attachEvents();
        start();

        return {
            cleanup() {
                state.running = false;
                cancelAnimationFrame(raf);
                detachEvents();
            },
            restart() {
                detachEvents();
                attachEvents();
                start();
            }
        };
    }

    // ---------- 4) Memory Match (polished) ----------
    function buildMemory(container, setScore, displayGameOver) {
        container.innerHTML = `
        <div class="memory-wrapper" style="max-width:840px;margin:0 auto;display:flex;flex-direction:column;gap:12px">
          <div class="memory-header" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
            <div class="memory-title" style="font-weight:900;font-size:20px">Aurora Memory</div>
            <div class="memory-meta" style="display:flex;align-items:center;gap:12px;font-size:13px;color:var(--muted)">
              <span id="memory-moves">Moves: 0</span>
              <span id="memory-accuracy">Accuracy: 100%</span>
              <button id="memory-reset" class="memory-reset" style="padding:6px 14px;border-radius:999px;border:none;background:#845ef7;color:#fff;font-weight:600;cursor:pointer">Shuffle</button>
            </div>
          </div>
          <div id="mem-board" class="mem-grid" role="grid" aria-label="Memory board"></div>
        </div>
      `;

        const gridEl = container.querySelector('#mem-board');
        const movesEl = container.querySelector('#memory-moves');
        const accuracyEl = container.querySelector('#memory-accuracy');
        const resetBtn = container.querySelector('#memory-reset');

        const symbols = ['ðŸ‰', 'ðŸ', 'ðŸ«', 'ðŸ¥', 'ðŸ“', 'ðŸ‹', 'ðŸ‡', 'ðŸ¥¥', 'ðŸ’', 'ðŸ‘'];

        const state = {
            deck: [],
            first: null,
            second: null,
            locked: false,
            moves: 0,
            matches: 0,
            startTime: null
        };

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function buildDeck() {
            const pairs = symbols.slice(0, 8);
            const deck = pairs.concat(pairs).map((symbol, index) => ({
                id: index,
                symbol,
                flipped: false,
                solved: false
            }));
            shuffle(deck);
            state.deck = deck;
        }

        function renderCard(card) {
            const button = document.createElement('button');
            button.className = 'mem-card' + (card.solved ? ' matched' : '');
            button.setAttribute('data-id', card.id);
            button.setAttribute('role', 'gridcell');
            button.setAttribute('aria-pressed', card.flipped || card.solved ? 'true' : 'false');

            const inner = document.createElement('div');
            inner.className = 'mem-inner' + ((card.flipped || card.solved) ? ' revealed' : '');
            const front = document.createElement('div');
            front.className = 'mem-front';
            front.textContent = card.symbol;
            const back = document.createElement('div');
            back.className = 'mem-back';
            back.textContent = '?';
            inner.appendChild(front);
            inner.appendChild(back);
            button.appendChild(inner);

            return button;
        }

        function updateHUD() {
            movesEl.textContent = 'Moves: ' + state.moves;
            const accuracy = state.moves === 0 ? 100 : Math.round((state.matches / state.moves) * 100);
            accuracyEl.textContent = 'Accuracy: ' + accuracy + '%';
            setScore('Score: ' + (state.matches * 25));
        }

        function renderGrid() {
            gridEl.innerHTML = '';
            state.deck.forEach(card => {
                const cardEl = renderCard(card);
                gridEl.appendChild(cardEl);
            });
        }

        function resetGame() {
            state.first = null;
            state.second = null;
            state.locked = false;
            state.moves = 0;
            state.matches = 0;
            state.startTime = performance.now();
            buildDeck();
            renderGrid();
            updateHUD();
        }

        function handleMatch() {
            state.matches += 1;
            const totalPairs = state.deck.length / 2;
            if (state.matches === totalPairs) {
                const elapsed = Math.round((performance.now() - state.startTime) / 1000);
                if (displayGameOver) {
                    displayGameOver('Score', state.matches * 25);
                } else {
                    setTimeout(() => {
                        alert(`You matched all pairs in ${state.moves} moves (${elapsed}s)!`);
                    }, 300);
                }
            }
        }

        function flipCard(card) {
            if (card.flipped || card.solved || state.locked) return;
            card.flipped = true;

            if (!state.first) {
                state.first = card;
            } else if (!state.second) {
                state.second = card;
                state.locked = true;
                state.moves += 1;
                updateHUD();

                if (state.first.symbol === state.second.symbol) {
                    state.first.solved = true;
                    state.second.solved = true;
                    state.locked = false;
                    state.first = null;
                    state.second = null;
                    handleMatch();
                } else {
                    setTimeout(() => {
                        state.first.flipped = false;
                        state.second.flipped = false;
                        state.first = null;
                        state.second = null;
                        state.locked = false;
                        renderGrid();
                    }, 700);
                }
            }

            renderGrid();
        }

        function onGridClick(event) {
            const button = event.target.closest('.memory-card');
            if (!button) return;
            const id = Number(button.dataset.id);
            const card = state.deck.find(entry => entry.id === id);
            if (!card) return;
            flipCard(card);
        }

        function cleanup() {
            gridEl.removeEventListener('click', onGridClick);
            resetBtn.removeEventListener('click', resetGame);
        }

        gridEl.addEventListener('click', onGridClick);
        resetBtn.addEventListener('click', resetGame);

        resetGame();

        return {
            cleanup,
            restart() {
                cleanup();
                gridEl.addEventListener('click', onGridClick);
                resetBtn.addEventListener('click', resetGame);
                resetGame();
            }
        };
    }

    // ---------- 5) Whack-a-Mole ----------
    function buildWhack(container, setScore) {
        container.innerHTML = `<div style="max-width:720px;margin:0 auto"><div style="font-weight:900">Whack-a-Mole</div><div id="whack-board" class="whack-grid" style="margin-top:12px"></div><div style="margin-top:10px;color:var(--muted)">30 second round â€” tap moles to score</div></div>`;
        const board = container.querySelector('#whack-board');
        const holes = 8;
        let active = -1, score = 0, time = 30;
        setScore('Score: 0');

        for (let i = 0; i < holes; i++) {
            const hole = document.createElement('div'); hole.className = 'hole';
            const mole = document.createElement('div'); mole.className = 'mole'; mole.textContent = 'ðŸ¹';
            hole.appendChild(mole);
            hole.addEventListener('click', () => {
                if (mole.classList.contains('up')) { score += 1; setScore('Score: ' + score); mole.classList.remove('up'); active = -1; }
            });
            board.appendChild(hole);
        }

        function popRandom() {
            if (active !== -1) return;
            active = Math.floor(Math.random() * holes);
            const mole = board.children[active].querySelector('.mole');
            mole.classList.add('up');
            setTimeout(() => { if (mole.classList.contains('up')) { mole.classList.remove('up'); active = -1; } }, 800 + Math.random() * 600);
        }

        const popInterval = setInterval(() => popRandom(), 700);
        const timerInterval = setInterval(() => {
            time--;
            setScore('Score: ' + score + ' | Time: ' + time + 's');
            if (time <= 0) { clearInterval(popInterval); clearInterval(timerInterval); setScore('Final: ' + score); }
        }, 1000);

        return {
            cleanup() { clearInterval(popInterval); clearInterval(timerInterval); },
            restart() { active = -1; score = 0; time = 30; setScore('Score: 0'); }
        };
    }

    // ---------- 6) Flappy (polished) ----------
    function buildFlappy(container, setScore) {
        container.innerHTML = `
        <div style="display:flex;flex-direction:column;align-items:center">
          <div style="font-weight:900">Flappy</div>
          <canvas id="flappy-canvas" width="420" height="360" style="background:#071827;border-radius:8px;margin-top:10px"></canvas>
          <div style="margin-top:8px;color:var(--muted);font-size:13px">Tap/click or Space to flap</div>
        </div>`;
        const canvas = container.querySelector('#flappy-canvas');
        const ctx = canvas.getContext('2d');
        let bird = { x: 70, y: 180, vy: 0 };
        const gravity = 0.6, flap = -9;
        let pipes = []; let frames = 0; let score = 0; let running = true;
        setScore('Score: 0');

        function spawnPipe() {
            const gap = 120;
            const top = 40 + Math.random() * (canvas.height - gap - 80);
            pipes.push({ x: canvas.width, top, gap, w: 46 });
        }

        function update() {
            frames++;
            bird.vy += gravity; bird.y += bird.vy;
            if (frames % 100 === 0) spawnPipe();
            pipes.forEach(p => p.x -= 2.6);
            // remove offscreen and count
            if (pipes.length && pipes[0].x + pipes[0].w < 0) { pipes.shift(); score++; setScore('Score: ' + score); }
            // collision
            if (bird.y + 12 > canvas.height || bird.y - 12 < 0) gameOver();
            for (const p of pipes) {
                if (bird.x + 12 > p.x && bird.x - 12 < p.x + p.w) {
                    if (bird.y - 12 < p.top || bird.y + 12 > p.top + p.gap) gameOver();
                }
            }
        }
        // Helper for color manipulation
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            const RR = ((R.toString(16).length == 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length == 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length == 1) ? "0" + B.toString(16) : B.toString(16));
            return "#" + RR + GG + BB;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Add subtle parallax background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGrad.addColorStop(0, '#0a4f6a');
            bgGrad.addColorStop(1, '#071827');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Bird with 3D effect
            ctx.save();
            ctx.translate(bird.x, bird.y);
            ctx.rotate(bird.vy * 0.08); // Tilt based on velocity

            // Bird body glow
            ctx.shadowColor = 'rgba(255,213,79,0.4)';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffd54f';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            // Wing
            ctx.fillStyle = shadeColor('#ffd54f', -20);
            ctx.beginPath();
            ctx.ellipse(-8, 0, 6, 4, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;

            // Pipes with 3D effect
            pipes.forEach(p => {
                // Top pipe
                const gradTop = ctx.createLinearGradient(p.x, 0, p.x + p.w, 0);
                gradTop.addColorStop(0, '#43a047');
                gradTop.addColorStop(0.5, '#66bb6a');
                gradTop.addColorStop(1, '#43a047');
                ctx.fillStyle = gradTop;
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.fillRect(p.x, 0, p.w, p.top);

                // Bottom pipe
                const gradBottom = ctx.createLinearGradient(p.x, p.top + p.gap, p.x + p.w, p.top + p.gap);
                gradBottom.addColorStop(0, '#43a047');
                gradBottom.addColorStop(0.5, '#66bb6a');
                gradBottom.addColorStop(1, '#43a047');
                ctx.fillStyle = gradBottom;
                ctx.fillRect(p.x, p.top + p.gap, p.w, canvas.height - (p.top + p.gap));
            });
        }

        function flapIt() { bird.vy = flap; }
        function gameOver() { running = false; setScore('Final: ' + score); }
        function loop() { if (running) { update(); draw(); raf = requestAnimationFrame(loop); } }
        let raf = requestAnimationFrame(loop);
        // controls
        function onKey(e) { if (e.code === 'Space') { e.preventDefault(); flapIt(); } }
        canvas.addEventListener('click', flapIt);
        window.addEventListener('keydown', onKey);

        return {
            cleanup() { cancelAnimationFrame(raf); canvas.removeEventListener('click', flapIt); window.removeEventListener('keydown', onKey); },
            restart() { bird = { x: 70, y: 180, vy: 0 }; pipes = []; frames = 0; score = 0; running = true; setScore('Score: 0'); raf = requestAnimationFrame(loop); }
        };
    }

    // ---------- Life Sim (BitLife-style) ----------
    function buildLifeSim(container, setScore) {
        const stats = {
            health: 100,
            happiness: 100,
            money: 0,
            age: 0
        };

        const events = [
            "You got a good grade in school! +10 happiness",
            "You caught a cold. -10 health",
            "You made a new friend! +15 happiness",
            "You found $20 on the street! +20 money",
            "You had a bad day at school. -5 happiness",
            "You exercised and felt great! +10 health",
            "You got in trouble. -10 happiness",
            "Your parents gave you allowance! +50 money",
            "You helped someone and felt good! +5 happiness",
            "You ate healthy food! +5 health"
        ];

        const jobs = [
            { title: "Student", salary: 0 },
            { title: "Part-time Worker", salary: 100 },
            { title: "Office Worker", salary: 500 },
            { title: "Manager", salary: 1000 },
            { title: "CEO", salary: 5000 }
        ];

        let currentJob = jobs[0];
        let log = [];

        container.innerHTML = `
        <div class="life-sim">
          <div class="life-header">
            <h3 style="margin:0">Your Life</h3>
            <div class="score-pill">Age: ${stats.age}</div>
          </div>
          
          <div class="life-stats">
            <div class="life-stat">
              <div class="stat-label">Health</div>
              <div class="stat-value">${stats.health}%</div>
            </div>
            <div class="life-stat">
              <div class="stat-label">Happiness</div>
              <div class="stat-value">${stats.happiness}%</div>
            </div>
            <div class="life-stat">
              <div class="stat-label">Money</div>
              <div class="stat-value">$${stats.money}</div>
            </div>
            <div class="life-stat">
              <div class="stat-label">Job</div>
              <div class="stat-value">${currentJob.title}</div>
            </div>
          </div>

          <div class="life-log" id="lifeLog"></div>

          <div class="life-actions">
            <button class="action-btn" id="ageBtn">Age Up</button>
            <button class="action-btn" id="workBtn">Work</button>
            <button class="action-btn" id="studyBtn">Study</button>
            <button class="action-btn" id="socialBtn">Socialize</button>
          </div>
        </div>
      `;

        function updateStats() {
            const statDivs = container.querySelectorAll('.life-stat');
            statDivs[0].querySelector('.stat-value').textContent = stats.health + '%';
            statDivs[1].querySelector('.stat-value').textContent = stats.happiness + '%';
            statDivs[2].querySelector('.stat-value').textContent = '$' + stats.money;
            statDivs[3].querySelector('.stat-value').textContent = currentJob.title;
            setScore(`Age: ${stats.age} | Money: $${stats.money}`);
        }

        function addLogEntry(text) {
            log.unshift({ age: stats.age, text });
            const logDiv = container.querySelector('#lifeLog');
            logDiv.innerHTML = log.slice(0, 10).map(entry => `
          <div class="log-entry">
            <span class="entry-age">Age ${entry.age}:</span>
            ${entry.text}
          </div>
        `).join('');
        }

        function randomEvent() {
            const event = events[Math.floor(Math.random() * events.length)];
            if (event.includes('health')) stats.health = Math.min(100, Math.max(0, stats.health + parseInt(event.match(/-?\d+/)[0])));
            if (event.includes('happiness')) stats.happiness = Math.min(100, Math.max(0, stats.happiness + parseInt(event.match(/-?\d+/)[0])));
            if (event.includes('money')) stats.money += parseInt(event.match(/-?\d+/)[0]);
            addLogEntry(event);
        }

        container.querySelector('#ageBtn').addEventListener('click', () => {
            stats.age++;
            stats.money += currentJob.salary;
            stats.health = Math.max(0, stats.health - 5);
            stats.happiness = Math.max(0, stats.happiness - 5);
            randomEvent();
            if (stats.age % 5 === 0 && currentJob.title !== "CEO") {
                const nextJob = jobs[jobs.indexOf(currentJob) + 1];
                if (nextJob) {
                    currentJob = nextJob;
                    addLogEntry(`You got promoted to ${currentJob.title}!`);
                }
            }
            updateStats();
            if (stats.health <= 0) {
                addLogEntry("Game Over - You ran out of health!");
                container.querySelector('#ageBtn').disabled = true;
            }
        });

        container.querySelector('#workBtn').addEventListener('click', () => {
            stats.money += currentJob.salary / 2;
            stats.happiness = Math.max(0, stats.happiness - 10);
            addLogEntry(`You worked extra hours and earned $${currentJob.salary / 2}!`);
            updateStats();
        });

        container.querySelector('#studyBtn').addEventListener('click', () => {
            stats.happiness = Math.max(0, stats.happiness - 5);
            addLogEntry("You studied hard and gained knowledge!");
            updateStats();
        });

        container.querySelector('#socialBtn').addEventListener('click', () => {
            stats.happiness = Math.min(100, stats.happiness + 15);
            stats.money = Math.max(0, stats.money - 20);
            addLogEntry("You went out with friends! +15 happiness, -$20");
            updateStats();
        });

        return {
            cleanup() { /* Nothing to clean up */ },
            restart() {
                stats.health = 100;
                stats.happiness = 100;
                stats.money = 0;
                stats.age = 0;
                currentJob = jobs[0];
                log = [];
                updateStats();
                container.querySelector('#ageBtn').disabled = false;
                container.querySelector('#lifeLog').innerHTML = '';
            }
        };
    }

    // ---------- Drive Rush (Drive Mad-style) ----------
    function buildDrive(container, setScore) {
        container.innerHTML = `
        <div class="drive-wrapper">
          <iframe
            src="Drive-Mad-main/index.html"
            class="drive-frame"
            title="Drive Mad"
            allow="fullscreen"
          ></iframe>
          <div class="drive-help">Use arrow keys or WASD. Press Restart to reload the level.</div>
        </div>
      `;

        const frame = container.querySelector('.drive-frame');
        setScore('Drive Mad');

        function reloadFrame() {
            try {
                // Reload via same-origin access when available
                frame.contentWindow.location.reload();
            } catch (err) {
                // Fallback for any load issues
                const url = frame.getAttribute('src');
                frame.src = '';
                frame.src = url;
            }
        }

        return {
            cleanup() {
                frame.src = 'about:blank';
            },
            restart() {
                reloadFrame();
            }
        };
    }

    // ---------- Basket Random ----------
    function buildBasketRandom(container, setScore) {
        container.innerHTML = `
        <div class="basket-wrapper">
          <iframe
            src="https://ubg98.github.io/BasketRandom/"
            class="basket-frame"
            title="Basket Random"
            allow="fullscreen"
          ></iframe>
          <div class="basket-help">
            Basket Random plays best with keyboard controls (W or â†‘ to jump). This loads from the UBG mirror, so youâ€™ll need an internet connection.
          </div>
        </div>
      `;

        const frame = container.querySelector('.basket-frame');
        setScore('Basket Random');

        function reloadFrame() {
            const url = frame.getAttribute('src');
            frame.src = '';
            frame.src = url;
        }

        return {
            cleanup() {
                frame.src = 'about:blank';
            },
            restart() {
                reloadFrame();
            }
        };
    }

    // ---------- Ancient Beast ----------
    function buildAncient(container, setScore) {
        container.innerHTML = `
        <div class="ancient-wrapper">
          <iframe
            src="https://ancientbeast.com/play"
            class="ancient-frame"
            title="Ancient Beast"
            allow="fullscreen"
          ></iframe>
          <div class="ancient-help">
            Ancient Beast is a turn-based strategy game. If you have a local build, replace the iframe source with your hosted path.
          </div>
        </div>
      `;

        const frame = container.querySelector('.ancient-frame');
        setScore('Ancient Beast');

        function reloadFrame() {
            const url = frame.getAttribute('src');
            frame.src = '';
            frame.src = url;
        }

        return {
            cleanup() {
                frame.src = 'about:blank';
            },
            restart() {
                reloadFrame();
            }
        };
    }

    // ---------- Block Craft ----------
    function buildCraft(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="font-weight:900;margin-bottom:10px">Block Craft</div>
          <div class="craft-world" id="craftWorld"></div>
          <div class="craft-inventory" id="inventory">
            <div class="inv-item" style="background:#4a6b82">ðŸŸ¦</div>
            <div class="inv-item" style="background:#388e3c">ðŸŸ©</div>
            <div class="inv-item" style="background:#ffa000">ðŸŸ¨</div>
            <div class="inv-item" style="background:#d32f2f">ðŸŸ¥</div>
          </div>
        </div>
      `;

        const world = container.querySelector('#craftWorld');
        const blockSize = 30;
        let selectedBlock = '#4a6b82';
        let blocks = [];

        // Create ground
        for (let x = 0; x < world.offsetWidth; x += blockSize) {
            createBlock(x, world.offsetHeight - blockSize, '#388e3c');
        }

        function createBlock(x, y, color) {
            const block = document.createElement('div');
            block.className = 'craft-block';
            block.style.left = x + 'px';
            block.style.top = y + 'px';
            block.style.background = color;
            world.appendChild(block);
            blocks.push(block);

            block.addEventListener('contextmenu', e => {
                e.preventDefault();
                block.remove();
                blocks = blocks.filter(b => b !== block);
            });
        }

        world.addEventListener('click', e => {
            const rect = world.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / blockSize) * blockSize;
            const y = Math.floor((e.clientY - rect.top) / blockSize) * blockSize;

            // Check if block exists at position
            const existing = blocks.find(b => {
                const bRect = b.getBoundingClientRect();
                return bRect.left === x + rect.left && bRect.top === y + rect.top;
            });

            if (!existing) {
                createBlock(x, y, selectedBlock);
            }
        });

        container.querySelector('#inventory').addEventListener('click', e => {
            if (e.target.classList.contains('inv-item')) {
                selectedBlock = getComputedStyle(e.target).backgroundColor;
                document.querySelectorAll('.inv-item').forEach(item => item.style.border = '');
                e.target.style.border = '2px solid #39c5ff';
            }
        });

        return {
            cleanup() { },
            restart() {
                blocks.forEach(b => b.remove());
                blocks = [];
                for (let x = 0; x < world.offsetWidth; x += blockSize) {
                    createBlock(x, world.offsetHeight - blockSize, '#388e3c');
                }
            }
        };
    }

    // ---------- attach tiles to builders ----------
    document.getElementById('tile-2048').addEventListener('click', () => showGame('2048', build2048));
    document.getElementById('tile-snake').addEventListener('click', () => showGame('Snake', buildSnake));
    document.getElementById('tile-breakout').addEventListener('click', () => showGame('Breakout', buildBreakout));
    document.getElementById('tile-memory').addEventListener('click', () => showGame('Memory', buildMemory));
    document.getElementById('tile-whack').addEventListener('click', () => showGame('Whack-a-Mole', buildWhack));
    document.getElementById('tile-flappy').addEventListener('click', () => showGame('Flappy', buildFlappy));
    document.getElementById('tile-bitlife').addEventListener('click', () => showGame('Life Sim', buildLifeSim));
    document.getElementById('tile-drive').addEventListener('click', () => showGame('Drive Mad', buildDrive));
    document.getElementById('tile-ancient').addEventListener('click', () => showGame('Ancient Beast', buildAncient));
    document.getElementById('tile-craft').addEventListener('click', () => showGame('Block Craft', buildCraft));
    document.getElementById('tile-runner').addEventListener('click', () => showGame('Temple Run', buildRunner));
    document.getElementById('tile-candy').addEventListener('click', () => showGame('Candy Match', buildCandy));
    document.getElementById('tile-pacman').addEventListener('click', () => showGame('Maze Chase', buildPacman));
    document.getElementById('tile-tetris').addEventListener('click', () => showGame('Block Drop', buildTetris));
    document.getElementById('tile-words').addEventListener('click', () => showGame('Word Quest', buildWords));
    document.getElementById('tile-piano').addEventListener('click', () => showGame('Piano Tiles', buildPiano));
    document.getElementById('tile-bubble').addEventListener('click', () => showGame('Bubble Pop', buildBubble));
    document.getElementById('tile-tower').addEventListener('click', () => showGame('Tower Stack', buildTower));
    document.getElementById('tile-race').addEventListener('click', () => showGame('Speed Racer', buildRace));

    // ---------- Temple Runner ----------
    function buildRunner(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="font-weight:900;margin-bottom:10px">Temple Run</div>
          <div class="runner-game">
            <div class="runner-track">
              <div id="runner-player" class="runner-player"></div>
            </div>
          </div>
        </div>
      `;

        const game = container.querySelector('.runner-game');
        const track = container.querySelector('.runner-track');
        const player = document.getElementById('runner-player');

        let score = 0;
        let speed = 5;
        let lane = 1; // 0=left, 1=center, 2=right
        let jumping = false;
        let obstacles = [];
        let gameActive = true;

        function updateScore(n) {
            score = n;
            setScore('Score: ' + score);
        }

        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.className = 'runner-obstacle';
            const lane = Math.floor(Math.random() * 3);
            const width = 40;
            const height = 40;
            obstacle.style.width = width + 'px';
            obstacle.style.height = height + 'px';
            obstacle.style.left = (lane * 150 + 80) + 'px';
            obstacle.style.top = '-50px';
            track.appendChild(obstacle);
            return { el: obstacle, lane };
        }

        function movePlayer(newLane) {
            if (newLane >= 0 && newLane <= 2) {
                lane = newLane;
                player.style.transform = `translateX(${lane * 150}px)`;
            }
        }

        function jump() {
            if (!jumping) {
                jumping = true;
                player.style.bottom = '100px';
                setTimeout(() => {
                    player.style.bottom = '20px';
                    jumping = false;
                }, 500);
            }
        }

        function update() {
            if (!gameActive) return;

            // Create obstacles
            if (Math.random() < 0.02) {
                obstacles.push(createObstacle());
            }

            // Move obstacles
            obstacles.forEach((obs, i) => {
                const top = parseFloat(obs.el.style.top) || 0;
                obs.el.style.top = (top + speed) + 'px';

                // Check collision
                if (top > 300 && top < 360 && obs.lane === lane && !jumping) {
                    gameOver();
                }

                // Remove if off screen
                if (top > 400) {
                    obs.el.remove();
                    obstacles.splice(i, 1);
                    updateScore(score + 1);
                    speed = Math.min(15, 5 + Math.floor(score / 20));
                }
            });

            if (gameActive) requestAnimationFrame(update);
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Score', score);
        }

        // Controls
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') movePlayer(Math.max(0, lane - 1));
            if (e.key === 'ArrowRight') movePlayer(Math.min(2, lane + 1));
            if (e.key === 'ArrowUp' || e.key === ' ') jump();
        });

        // Touch controls
        let touchStartX = 0;
        game.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });

        game.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchEndX - touchStartX;
            if (Math.abs(diff) > 30) {
                if (diff > 0) movePlayer(Math.min(2, lane + 1));
                else movePlayer(Math.max(0, lane - 1));
            } else {
                jump();
            }
        });

        // Initial setup
        player.style.bottom = '20px';
        player.style.left = '80px';
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                window.removeEventListener('keydown', movePlayer);
            },
            restart() {
                obstacles.forEach(obs => obs.el.remove());
                obstacles = [];
                score = 0;
                speed = 5;
                lane = 1;
                jumping = false;
                gameActive = true;
                movePlayer(1);
                updateScore(0);
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Candy Match ----------
    function buildCandy(container, setScore) {
        container.innerHTML = `
        <div style="max-width:600px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Candy Match</div>
            <div class="score-pill">Score: 0</div>
          </div>
          <div class="candy-board"></div>
        </div>
      `;

        const board = container.querySelector('.candy-board');
        const size = 8;
        const colors = ['#f44336', '#2196f3', '#4caf50', '#ff9800', '#9c27b0', '#ffeb3b'];
        let grid = [];
        let score = 0;
        let selected = null;

        function createGrid() {
            board.style.gridTemplateColumns = `repeat(${size}, 50px)`;
            grid = [];
            for (let i = 0; i < size; i++) {
                grid[i] = [];
                for (let j = 0; j < size; j++) {
                    const candy = document.createElement('div');
                    candy.className = 'candy';
                    candy.style.background = colors[Math.floor(Math.random() * colors.length)];
                    candy.dataset.row = i;
                    candy.dataset.col = j;
                    candy.addEventListener('click', () => selectCandy(i, j, candy));
                    board.appendChild(candy);
                    grid[i][j] = candy;
                }
            }
        }

        function selectCandy(row, col, candy) {
            if (selected) {
                if (selected.candy === candy) {
                    selected.candy.classList.remove('selected');
                    selected = null;
                } else if (isAdjacent(selected.row, selected.col, row, col)) {
                    swap(selected.row, selected.col, row, col);
                    selected.candy.classList.remove('selected');
                    selected = null;
                } else {
                    selected.candy.classList.remove('selected');
                    candy.classList.add('selected');
                    selected = { row, col, candy };
                }
            } else {
                candy.classList.add('selected');
                selected = { row, col, candy };
            }
        }

        function isAdjacent(r1, c1, r2, c2) {
            return (Math.abs(r1 - r2) === 1 && c1 === c2) ||
                (Math.abs(c1 - c2) === 1 && r1 === r2);
        }

        function swap(r1, c1, r2, c2) {
            const color1 = grid[r1][c1].style.background;
            const color2 = grid[r2][c2].style.background;
            grid[r1][c1].style.background = color2;
            grid[r2][c2].style.background = color1;
            checkMatches();
        }

        function checkMatches() {
            let matches = new Set();

            // Check rows
            for (let i = 0; i < size; i++) {
                let count = 1;
                let color = grid[i][0].style.background;
                for (let j = 1; j < size; j++) {
                    if (grid[i][j].style.background === color) {
                        count++;
                        if (count >= 3) {
                            for (let k = j; k > j - count; k--) {
                                matches.add(grid[i][k]);
                            }
                        }
                    } else {
                        count = 1;
                        color = grid[i][j].style.background;
                    }
                }
            }

            // Check columns
            for (let j = 0; j < size; j++) {
                let count = 1;
                let color = grid[0][j].style.background;
                for (let i = 1; i < size; i++) {
                    if (grid[i][j].style.background === color) {
                        count++;
                        if (count >= 3) {
                            for (let k = i; k > i - count; k--) {
                                matches.add(grid[k][j]);
                            }
                        }
                    } else {
                        count = 1;
                        color = grid[i][j].style.background;
                    }
                }
            }

            if (matches.size > 0) {
                score += matches.size * 10;
                setScore('Score: ' + score);
                matches.forEach(candy => {
                    candy.style.background = colors[Math.floor(Math.random() * colors.length)];
                    candy.classList.add('matched');
                    setTimeout(() => candy.classList.remove('matched'), 300);
                });
            }
        }

        createGrid();

        return {
            cleanup() { },
            restart() {
                score = 0;
                selected = null;
                setScore('Score: 0');
                board.innerHTML = '';
                createGrid();
            }
        };
    }

    // ---------- Maze Chase (Pac-Man style) ----------
    function buildPacman(container, setScore) {
        container.innerHTML = `
        <div style="max-width:600px;margin:0 auto">
          <div style="font-weight:900;margin-bottom:10px">Maze Chase</div>
          <div class="maze-game" style="width:600px;height:400px">
            <div id="maze-player" class="maze-player"></div>
          </div>
        </div>
      `;

        const game = container.querySelector('.maze-game');
        const player = document.getElementById('maze-player');
        const cellSize = 20;
        const cols = Math.floor(game.offsetWidth / cellSize);
        const rows = Math.floor(game.offsetHeight / cellSize);
        let score = 0;
        let ghosts = [];
        let dots = [];
        let walls = [];
        let playerPos = { x: 1, y: 1 };
        let gameActive = true;

        // Create maze using recursive backtracking
        const maze = Array(rows).fill().map(() => Array(cols).fill(1));

        function carve(x, y) {
            maze[y][x] = 0;
            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]].sort(() => Math.random() - 0.5);

            for (let [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                if (newX > 0 && newX < cols - 1 && newY > 0 && newY < rows - 1 && maze[newY][newX] === 1) {
                    maze[y + dy / 2][x + dx / 2] = 0;
                    carve(newX, newY);
                }
            }
        }

        function initMaze() {
            carve(1, 1);

            // Create walls
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1) {
                        const wall = document.createElement('div');
                        wall.className = 'maze-wall';
                        wall.style.left = (x * cellSize) + 'px';
                        wall.style.top = (y * cellSize) + 'px';
                        wall.style.width = cellSize + 'px';
                        wall.style.height = cellSize + 'px';
                        game.appendChild(wall);
                        walls.push({ x, y, el: wall });
                    } else if (x > 1 || y > 1) { // Don't place dots near start
                        const dot = document.createElement('div');
                        dot.className = 'maze-dot';
                        dot.style.left = (x * cellSize + cellSize / 2) + 'px';
                        dot.style.top = (y * cellSize + cellSize / 2) + 'px';
                        dot.style.width = '4px';
                        dot.style.height = '4px';
                        game.appendChild(dot);
                        dots.push({ x, y, el: dot });
                    }
                }
            }

            // Create ghosts
            for (let i = 0; i < 4; i++) {
                const ghost = document.createElement('div');
                ghost.className = 'maze-ghost';
                ghost.style.width = (cellSize - 4) + 'px';
                ghost.style.height = (cellSize - 4) + 'px';
                ghost.style.left = ((cols - 2) * cellSize) + 'px';
                ghost.style.top = ((rows - 2) * cellSize) + 'px';
                game.appendChild(ghost);
                ghosts.push({
                    x: cols - 2,
                    y: rows - 2,
                    el: ghost,
                    dir: { x: 0, y: 0 }
                });
            }
        }

        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && maze[newY][newX] === 0) {
                playerPos.x = newX;
                playerPos.y = newY;
                player.style.left = (newX * cellSize) + 'px';
                player.style.top = (newY * cellSize) + 'px';

                // Collect dots
                dots = dots.filter(dot => {
                    if (Math.abs(dot.x - playerPos.x) < 0.5 && Math.abs(dot.y - playerPos.y) < 0.5) {
                        dot.el.remove();
                        score += 10;
                        setScore('Score: ' + score);
                        return false;
                    }
                    return true;
                });

                // Check win
                if (dots.length === 0) {
                    gameActive = false;
                    alert('You Win! Score: ' + score);
                }
            }
        }

        function moveGhosts() {
            ghosts.forEach(ghost => {
                if (Math.random() < 0.1) { // Change direction occasionally
                    const possible = [[0, 1], [1, 0], [0, -1], [-1, 0]].filter(([dx, dy]) => {
                        const newX = ghost.x + dx;
                        const newY = ghost.y + dy;
                        return newX >= 0 && newX < cols && newY >= 0 && newY < rows && maze[newY][newX] === 0;
                    });
                    if (possible.length) {
                        const [dx, dy] = possible[Math.floor(Math.random() * possible.length)];
                        ghost.dir = { x: dx, y: dy };
                    }
                }

                const newX = ghost.x + ghost.dir.x;
                const newY = ghost.y + ghost.dir.y;
                if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && maze[newY][newX] === 0) {
                    ghost.x = newX;
                    ghost.y = newY;
                    ghost.el.style.left = (newX * cellSize) + 'px';
                    ghost.el.style.top = (newY * cellSize) + 'px';

                    // Check collision with player
                    if (Math.abs(ghost.x - playerPos.x) < 0.5 && Math.abs(ghost.y - playerPos.y) < 0.5) {
                        gameActive = false;
                        displayGameOver('Score', score);
                    }
                }
            });
        }

        function update() {
            if (gameActive) {
                moveGhosts();
                requestAnimationFrame(update);
            }
        }

        // Controls
        window.addEventListener('keydown', e => {
            if (!gameActive) return;
            if (e.key === 'ArrowLeft') movePlayer(-1, 0);
            if (e.key === 'ArrowRight') movePlayer(1, 0);
            if (e.key === 'ArrowUp') movePlayer(0, -1);
            if (e.key === 'ArrowDown') movePlayer(0, 1);
        });

        // Touch controls
        let touchStartX = 0, touchStartY = 0;
        game.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        game.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                movePlayer(dx > 0 ? 1 : -1, 0);
            } else {
                movePlayer(0, dy > 0 ? 1 : -1);
            }
        });

        // Initial setup
        player.style.width = (cellSize - 4) + 'px';
        player.style.height = (cellSize - 4) + 'px';
        player.style.left = cellSize + 'px';
        player.style.top = cellSize + 'px';

        initMaze();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                window.removeEventListener('keydown', movePlayer);
            },
            restart() {
                gameActive = false;
                game.innerHTML = '<div id="maze-player" class="maze-player"></div>';
                player = document.getElementById('maze-player');
                player.style.width = (cellSize - 4) + 'px';
                player.style.height = (cellSize - 4) + 'px';
                player.style.left = cellSize + 'px';
                player.style.top = cellSize + 'px';
                playerPos = { x: 1, y: 1 };
                score = 0;
                ghosts = [];
                dots = [];
                walls = [];
                initMaze();
                gameActive = true;
                setScore('Score: 0');
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Block Drop (Tetris style) ----------
    function buildTetris(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;gap:20px;align-items:start">
            <div>
              <div style="font-weight:900;margin-bottom:10px">Block Drop</div>
              <div class="tetris-board"></div>
            </div>
            <div>
              <div style="margin-bottom:10px">Next:</div>
              <div class="tetris-next"></div>
            </div>
          </div>
        </div>
      `;

        const board = container.querySelector('.tetris-board');
        const nextDisplay = container.querySelector('.tetris-next');
        const rows = 20, cols = 10;
        let score = 0;
        let currentPiece = null;
        let nextPiece = null;
        let grid = [];
        let gameActive = true;

        const pieces = [
            { shape: [[1, 1, 1, 1]], color: '#00bcd4' },    // I
            { shape: [[1, 1, 1], [0, 1, 0]], color: '#9c27b0' },  // T
            { shape: [[1, 1, 1], [1, 0, 0]], color: '#ff9800' },  // L
            { shape: [[1, 1, 1], [0, 0, 1]], color: '#2196f3' },  // J
            { shape: [[1, 1], [1, 1]], color: '#ffeb3b' },    // O
            { shape: [[1, 1, 0], [0, 1, 1]], color: '#4caf50' }, // S
            { shape: [[0, 1, 1], [1, 1, 0]], color: '#f44336' }  // Z
        ];

        function createGrid() {
            board.style.gridTemplateColumns = `repeat(${cols}, 25px)`;
            nextDisplay.style.gridTemplateColumns = 'repeat(4, 25px)';

            grid = [];
            board.innerHTML = '';
            for (let i = 0; i < rows; i++) {
                grid[i] = [];
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    board.appendChild(cell);
                    grid[i][j] = cell;
                }
            }

            // Next piece display
            nextDisplay.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    nextDisplay.appendChild(cell);
                }
            }
        }

        function createPiece() {
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            return {
                shape: piece.shape,
                color: piece.color,
                x: Math.floor((cols - piece.shape[0].length) / 2),
                y: 0
            };
        }

        function drawPiece(piece, erase = false) {
            const color = erase ? '' : piece.color;
            piece.shape.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell && piece.y + i >= 0) {
                        grid[piece.y + i][piece.x + j].style.background = color;
                    }
                });
            });
        }

        function drawNextPiece(piece) {
            const cells = nextDisplay.children;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    cells[i * 4 + j].style.background = '';
                }
            }

            piece.shape.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell) {
                        cells[i * 4 + j].style.background = piece.color;
                    }
                });
            });
        }

        function canMove(piece, dx, dy) {
            return piece.shape.every((row, i) => {
                return row.every((cell, j) => {
                    if (!cell) return true;
                    const newX = piece.x + j + dx;
                    const newY = piece.y + i + dy;
                    return newX >= 0 && newX < cols && newY < rows &&
                        (newY < 0 || !grid[newY][newX].style.background);
                });
            });
        }

        function rotatePiece(piece) {
            const newShape = piece.shape[0].map((_, i) =>
                piece.shape.map(row => row[i]).reverse()
            );
            const newPiece = { ...piece, shape: newShape };
            if (canMove(newPiece, 0, 0)) {
                drawPiece(piece, true);
                piece.shape = newShape;
                drawPiece(piece);
            }
        }

        function checkLines() {
            for (let i = rows - 1; i >= 0; i--) {
                if (grid[i].every(cell => cell.style.background)) {
                    // Remove line
                    for (let j = i; j > 0; j--) {
                        for (let k = 0; k < cols; k++) {
                            grid[j][k].style.background = grid[j - 1][k].style.background;
                        }
                    }
                    // Clear top line
                    for (let k = 0; k < cols; k++) {
                        grid[0][k].style.background = '';
                    }
                    score += 100;
                    setScore('Score: ' + score);
                    i++; // Check the same line again
                }
            }
        }

        function update() {
            if (!gameActive) return;

            if (currentPiece) {
                if (canMove(currentPiece, 0, 1)) {
                    drawPiece(currentPiece, true);
                    currentPiece.y++;
                    drawPiece(currentPiece);
                } else {
                    checkLines();
                    currentPiece = nextPiece;
                    nextPiece = createPiece();
                    drawNextPiece(nextPiece);
                    if (!canMove(currentPiece, 0, 0)) {
                        gameActive = false;
                        displayGameOver('Score', score);
                        return;
                    }
                }
            } else {
                currentPiece = createPiece();
                nextPiece = createPiece();
                drawNextPiece(nextPiece);
            }

            setTimeout(update, 500 - Math.min(300, Math.floor(score / 1000) * 50));
        }

        // Controls
        window.addEventListener('keydown', e => {
            if (!gameActive || !currentPiece) return;
            if (e.key === 'ArrowLeft' && canMove(currentPiece, -1, 0)) {
                drawPiece(currentPiece, true);
                currentPiece.x--;
                drawPiece(currentPiece);
            }
            if (e.key === 'ArrowRight' && canMove(currentPiece, 1, 0)) {
                drawPiece(currentPiece, true);
                currentPiece.x++;
                drawPiece(currentPiece);
            }
            if (e.key === 'ArrowDown' && canMove(currentPiece, 0, 1)) {
                drawPiece(currentPiece, true);
                currentPiece.y++;
                drawPiece(currentPiece);
            }
            if (e.key === 'ArrowUp') {
                rotatePiece(currentPiece);
            }
        });

        createGrid();
        update();

        return {
            cleanup() {
                gameActive = false;
            },
            restart() {
                gameActive = false;
                score = 0;
                currentPiece = null;
                nextPiece = null;
                setScore('Score: 0');
                createGrid();
                gameActive = true;
                update();
            }
        };
    }

    // ---------- Word Quest ----------
    function buildWords(container, setScore) {
        container.innerHTML = `
        <div style="max-width:600px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Word Quest</div>
            <div class="score-pill">Found: 0/10</div>
          </div>
          <div class="word-grid"></div>
          <div class="word-list"></div>
        </div>
      `;

        const grid = container.querySelector('.word-grid');
        const wordList = container.querySelector('.word-list');
        const size = 12;
        const words = ['JAVASCRIPT', 'PYTHON', 'RUBY', 'JAVA', 'HTML', 'CSS', 'PHP', 'SQL', 'RUST', 'SWIFT'];
        let board = [];
        let foundWords = new Set();
        let selectedCells = [];

        function createGrid() {
            grid.style.gridTemplateColumns = `repeat(${size}, 40px)`;
            board = Array(size).fill().map(() => Array(size).fill(''));

            // Place words
            words.forEach(word => {
                let placed = false;
                while (!placed) {
                    const horizontal = Math.random() < 0.5;
                    const reverse = Math.random() < 0.3;
                    const w = reverse ? word.split('').reverse().join('') : word;

                    if (horizontal) {
                        const y = Math.floor(Math.random() * size);
                        const x = Math.floor(Math.random() * (size - word.length + 1));
                        if (canPlace(w, x, y, 1, 0)) {
                            placeWord(w, x, y, 1, 0);
                            placed = true;
                        }
                    } else {
                        const x = Math.floor(Math.random() * size);
                        const y = Math.floor(Math.random() * (size - word.length + 1));
                        if (canPlace(w, x, y, 0, 1)) {
                            placeWord(w, x, y, 0, 1);
                            placed = true;
                        }
                    }
                }
            });

            // Fill empty cells
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (!board[y][x]) {
                        board[y][x] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }

            // Create DOM elements
            grid.innerHTML = '';
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'word-cell';
                    cell.textContent = board[y][x];
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('mousedown', () => startSelection(cell));
                    cell.addEventListener('mouseover', () => continueSelection(cell));
                    grid.appendChild(cell);
                }
            }

            // Create word list
            wordList.innerHTML = words.map(word =>
                `<div class="word-item" data-word="${word}">${word}</div>`
            ).join('');
        }

        function canPlace(word, x, y, dx, dy) {
            for (let i = 0; i < word.length; i++) {
                const cx = x + i * dx;
                const cy = y + i * dy;
                if (board[cy][cx] && board[cy][cx] !== word[i]) return false;
            }
            return true;
        }

        function placeWord(word, x, y, dx, dy) {
            for (let i = 0; i < word.length; i++) {
                board[y + i * dy][x + i * dx] = word[i];
            }
        }

        function startSelection(cell) {
            selectedCells = [cell];
            cell.classList.add('selected');

            document.addEventListener('mouseup', checkWord);
        }

        function continueSelection(cell) {
            if (selectedCells.length && !selectedCells.includes(cell)) {
                const first = selectedCells[0];
                const dx = Math.abs(cell.dataset.x - first.dataset.x);
                const dy = Math.abs(cell.dataset.y - first.dataset.y);

                if (dx === selectedCells.length - 1 && dy === 0 ||
                    dy === selectedCells.length - 1 && dx === 0) {
                    cell.classList.add('selected');
                    selectedCells.push(cell);
                }
            }
        }

        function checkWord() {
            document.removeEventListener('mouseup', checkWord);

            const word = selectedCells.map(cell => cell.textContent).join('');
            const reverseWord = word.split('').reverse().join('');

            if (words.includes(word) || words.includes(reverseWord)) {
                if (!foundWords.has(word) && !foundWords.has(reverseWord)) {
                    foundWords.add(word);
                    selectedCells.forEach(cell => cell.style.background = '#4caf50');
                    wordList.querySelector(`[data-word="${word}"]`).style.opacity = '0.5';
                    setScore(`Found: ${foundWords.size}/10`);

                    if (foundWords.size === words.length) {
                        alert('Congratulations! You found all words!');
                    }
                }
            }

            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];
        }

        createGrid();

        return {
            cleanup() { },
            restart() {
                foundWords.clear();
                setScore('Found: 0/10');
                createGrid();
            }
        };
    }

    // ---------- Piano Tiles ----------
    function buildPiano(container, setScore) {
        container.innerHTML = `
        <div style="max-width:400px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Piano Tiles</div>
            <div class="score-pill">Score: 0</div>
          </div>
          <div class="piano-game"></div>
        </div>
      `;

        const game = container.querySelector('.piano-game');
        const lanes = 4;
        const laneWidth = game.offsetWidth / lanes;
        let tiles = [];
        let score = 0;
        let speed = 2;
        let gameActive = true;
        let lastTileTime = 0;
        let missedTile = false;

        function createLanes() {
            for (let i = 0; i < lanes; i++) {
                const lane = document.createElement('div');
                lane.className = 'piano-lane';
                lane.style.left = (i * laneWidth) + 'px';
                lane.style.width = laneWidth + 'px';
                game.appendChild(lane);
            }
        }

        function createTile() {
            const lane = Math.floor(Math.random() * lanes);
            const tile = document.createElement('div');
            tile.className = 'piano-tile';
            tile.style.left = (lane * laneWidth) + 'px';
            tile.style.width = laneWidth + 'px';
            tile.style.height = '80px';
            tile.style.top = '-80px';
            game.appendChild(tile);

            tile.addEventListener('click', () => {
                if (parseFloat(tile.style.top) < game.offsetHeight - 100) {
                    missedTile = true;
                    gameOver();
                } else {
                    score += 1;
                    setScore('Score: ' + score);
                    tile.remove();
                    tiles = tiles.filter(t => t !== tile);
                    speed = Math.min(8, 2 + score / 50);
                    playNote(lane);
                }
            });

            tiles.push(tile);
        }

        function playNote(lane) {
            const notes = [261.63, 293.66, 329.63, 349.23]; // C4, D4, E4, F4
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(notes[lane], audioContext.currentTime);

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        function update(timestamp) {
            if (!gameActive) return;

            // Create new tiles
            if (timestamp - lastTileTime > 1500 - score * 10) {
                createTile();
                lastTileTime = timestamp;
            }

            // Move tiles
            tiles.forEach(tile => {
                const top = parseFloat(tile.style.top) || 0;
                tile.style.top = (top + speed) + 'px';

                if (top > game.offsetHeight) {
                    missedTile = true;
                    gameOver();
                }
            });

            requestAnimationFrame(update);
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Score', score);
        }

        // Touch/mouse handling for mobile
        game.addEventListener('touchstart', e => {
            const touch = e.touches[0];
            const lane = Math.floor(touch.clientX / laneWidth);
            const tiles = Array.from(game.querySelectorAll('.piano-tile'));
            const laneTiles = tiles.filter(tile =>
                parseInt(tile.style.left) === lane * laneWidth
            );

            if (laneTiles.length) {
                const bottomTile = laneTiles.reduce((a, b) =>
                    parseFloat(a.style.top) > parseFloat(b.style.top) ? a : b
                );
                bottomTile.click();
            }
        });

        createLanes();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
            },
            restart() {
                tiles.forEach(tile => tile.remove());
                tiles = [];
                score = 0;
                speed = 2;
                missedTile = false;
                lastTileTime = 0;
                setScore('Score: 0');
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Bubble Pop ----------
    function buildBubble(container, setScore) {
        container.innerHTML = `
        <div style="max-width:600px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Bubble Pop</div>
            <div class="score-pill">Score: 0</div>
          </div>
          <div class="bubble-game">
            <div class="bubble-shooter"></div>
          </div>
        </div>
      `;

        const game = container.querySelector('.bubble-game');
        const shooter = game.querySelector('.bubble-shooter');
        const colors = ['#f44336', '#2196f3', '#4caf50', '#ff9800', '#9c27b0'];
        let bubbles = [];
        let score = 0;
        let gameActive = true;
        let angle = 0;
        let currentBubble = null;

        function createBubble(x, y, color = null) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            bubble.style.background = color || colors[Math.floor(Math.random() * colors.length)];
            game.appendChild(bubble);
            return bubble;
        }

        function initGrid() {
            const rows = 5;
            const cols = 10;
            const size = 40;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const x = j * (size + 2) + (i % 2) * (size / 2);
                    const y = i * (size - 10);
                    const bubble = createBubble(x, y);
                    bubbles.push({
                        el: bubble,
                        x: x,
                        y: y,
                        color: bubble.style.background
                    });
                }
            }
        }

        function updateShooter() {
            shooter.style.transform = `rotate(${angle}deg)`;
        }

        function shootBubble() {
            if (currentBubble) return;

            const shooterRect = shooter.getBoundingClientRect();
            const gameRect = game.getBoundingClientRect();
            const startX = shooterRect.left - gameRect.left + shooter.offsetWidth / 2 - 20;
            const startY = game.offsetHeight - 40;

            const bubble = createBubble(startX, startY, colors[Math.floor(Math.random() * colors.length)]);
            const radians = angle * Math.PI / 180;
            const speed = 10;
            const velocity = {
                x: Math.sin(radians) * speed,
                y: -Math.cos(radians) * speed
            };

            currentBubble = { el: bubble, x: startX, y: startY, velocity, color: bubble.style.background };
        }

        function findMatchingBubbles(bubble) {
            const matches = new Set([bubble]);
            const toCheck = [bubble];

            while (toCheck.length) {
                const current = toCheck.pop();
                const neighbors = bubbles.filter(b =>
                    b !== current &&
                    !matches.has(b) &&
                    b.color === current.color &&
                    Math.hypot(b.x - current.x, b.y - current.y) < 50
                );

                neighbors.forEach(n => {
                    matches.add(n);
                    toCheck.push(n);
                });
            }

            return matches;
        }

        function update() {
            if (!gameActive) return;

            if (currentBubble) {
                currentBubble.x += currentBubble.velocity.x;
                currentBubble.y += currentBubble.velocity.y;

                // Bounce off walls
                if (currentBubble.x < 0 || currentBubble.x > game.offsetWidth - 40) {
                    currentBubble.velocity.x *= -1;
                }

                // Check collision with existing bubbles
                for (const bubble of bubbles) {
                    const dx = bubble.x - currentBubble.x;
                    const dy = bubble.y - currentBubble.y;
                    const distance = Math.hypot(dx, dy);

                    if (distance < 40) {
                        // Snap to grid
                        const snapY = Math.round(currentBubble.y / 30) * 30;
                        currentBubble.y = snapY;
                        currentBubble.x = Math.round(currentBubble.x / 40) * 40;

                        bubbles.push({
                            el: currentBubble.el,
                            x: currentBubble.x,
                            y: currentBubble.y,
                            color: currentBubble.color
                        });

                        // Check for matches
                        const matches = findMatchingBubbles(bubbles[bubbles.length - 1]);
                        if (matches.size >= 3) {
                            matches.forEach(bubble => {
                                bubble.el.remove();
                                bubbles = bubbles.filter(b => b !== bubble);
                            });
                            score += matches.size * 10;
                            setScore('Score: ' + score);
                        }

                        currentBubble = null;
                        break;
                    }
                }

                // Update position
                if (currentBubble) {
                    currentBubble.el.style.left = currentBubble.x + 'px';
                    currentBubble.el.style.top = currentBubble.y + 'px';

                    // Check top collision
                    if (currentBubble.y < 0) {
                        bubbles.push({
                            el: currentBubble.el,
                            x: currentBubble.x,
                            y: 0,
                            color: currentBubble.color
                        });
                        currentBubble = null;
                    }
                }
            }

            requestAnimationFrame(update);
        }

        // Controls
        game.addEventListener('mousemove', e => {
            const rect = game.getBoundingClientRect();
            const x = e.clientX - rect.left - game.offsetWidth / 2;
            const y = rect.bottom - e.clientY;
            angle = Math.atan2(x, y) * 180 / Math.PI;
            angle = Math.max(-80, Math.min(80, angle));
            updateShooter();
        });

        game.addEventListener('click', shootBubble);

        // Touch controls
        game.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = game.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left - game.offsetWidth / 2;
            const y = rect.bottom - e.touches[0].clientY;
            angle = Math.atan2(x, y) * 180 / Math.PI;
            angle = Math.max(-80, Math.min(80, angle));
            updateShooter();
        });

        game.addEventListener('touchend', shootBubble);

        // Setup
        shooter.style.width = '40px';
        shooter.style.height = '40px';
        shooter.style.background = '#2196f3';
        shooter.style.borderRadius = '50% 50% 0 0';

        initGrid();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
            },
            restart() {
                bubbles.forEach(b => b.el.remove());
                bubbles = [];
                if (currentBubble) {
                    currentBubble.el.remove();
                    currentBubble = null;
                }
                score = 0;
                setScore('Score: 0');
                initGrid();
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Tower Stack ----------
    function buildTower(container, setScore) {
        container.innerHTML = `
        <div style="max-width:600px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Tower Stack</div>
            <div class="score-pill">Height: 0</div>
          </div>
          <div class="tower-game">
            <div id="tower-base" style="position:absolute;bottom:0;width:100%;height:60px;background:#1a3c4d"></div>
          </div>
        </div>
      `;

        const game = container.querySelector('.tower-game');
        const baseWidth = 200;
        const blockHeight = 40;
        let blocks = [];
        let currentBlock = null;
        let direction = 1;
        let speed = 3;
        let score = 0;
        let gameActive = true;

        function createBlock(width, y) {
            const block = document.createElement('div');
            block.className = 'tower-block';
            block.style.width = width + 'px';
            block.style.height = blockHeight + 'px';
            block.style.bottom = y + 'px';
            game.appendChild(block);
            return block;
        }

        function spawnBlock() {
            const lastBlock = blocks[blocks.length - 1];
            const width = lastBlock ? lastBlock.width : baseWidth;
            const y = blocks.length * blockHeight;
            const x = -width;

            const block = createBlock(width, y);
            currentBlock = {
                el: block,
                width,
                x,
                y
            };
        }

        function dropBlock() {
            if (!currentBlock) return;

            const lastBlock = blocks[blocks.length - 1];
            const lastX = lastBlock ? lastBlock.x : (game.offsetWidth - baseWidth) / 2;
            const overhang = Math.abs(currentBlock.x - lastX);

            if (overhang >= currentBlock.width) {
                // Missed completely
                gameOver();
                return;
            }

            // Calculate new width
            const newWidth = currentBlock.width - overhang;
            currentBlock.el.style.width = newWidth + 'px';
            currentBlock.width = newWidth;
            currentBlock.x = lastX + (currentBlock.x > lastX ? overhang : 0);
            currentBlock.el.style.left = currentBlock.x + 'px';

            blocks.push(currentBlock);
            score++;
            setScore('Height: ' + score);

            // Increase difficulty
            speed = Math.min(8, 3 + score / 10);

            spawnBlock();
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Height', score);
        }

        function update() {
            if (!gameActive || !currentBlock) return;

            currentBlock.x += speed * direction;
            currentBlock.el.style.left = currentBlock.x + 'px';

            if (currentBlock.x + currentBlock.width > game.offsetWidth) {
                direction = -1;
            } else if (currentBlock.x < 0) {
                direction = 1;
            }

            requestAnimationFrame(update);
        }

        // Controls
        game.addEventListener('click', dropBlock);
        game.addEventListener('touchend', dropBlock);

        // Start game
        const base = document.getElementById('tower-base');
        base.style.left = (game.offsetWidth - baseWidth) / 2 + 'px';
        base.style.width = baseWidth + 'px';
        spawnBlock();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
            },
            restart() {
                blocks.forEach(b => b.el.remove());
                blocks = [];
                if (currentBlock) {
                    currentBlock.el.remove();
                    currentBlock = null;
                }
                score = 0;
                speed = 3;
                direction = 1;
                setScore('Height: 0');
                spawnBlock();
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Solitaire ----------
    function buildSolitaire(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Solitaire</div>
            <div class="score-pill">Moves: 0</div>
          </div>
          <div class="solitaire-table"></div>
        </div>
      `;

        const table = container.querySelector('.solitaire-table');
        let moves = 0;
        let gameActive = true;
        let selectedCard = null;
        let deck = [];
        let drawPile = [];
        let wastePile = [];
        let foundations = [[], [], [], []];
        let tableaus = [[], [], [], [], [], [], []];

        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const COLORS = {
            'â™ ': 'black',
            'â™¥': 'red',
            'â™¦': 'red',
            'â™£': 'black'
        };

        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (let value = 1; value <= 13; value++) {
                    deck.push({ suit, value, faceUp: false });
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createCardElement(card, draggable = true) {
            const el = document.createElement('div');
            el.className = 'solitaire-card';
            if (!card.faceUp) {
                el.classList.add('face-down');
                el.textContent = 'ðŸ‚ ';
                return el;
            }

            el.dataset.suit = card.suit;
            el.dataset.value = card.value;
            el.draggable = draggable;

            const value = card.value === 1 ? 'A' :
                card.value === 11 ? 'J' :
                    card.value === 12 ? 'Q' :
                        card.value === 13 ? 'K' : card.value;

            el.innerHTML = `
          <div class="card-value top">${value}</div>
          <div class="card-suit ${COLORS[card.suit]}">${card.suit}</div>
          <div class="card-value bottom">${value}</div>
        `;
            return el;
        }

        function setupGame() {
            // Create deck area
            const deckArea = document.createElement('div');
            deckArea.className = 'solitaire-deck-area';
            table.appendChild(deckArea);

            // Create draw pile
            const drawPileEl = document.createElement('div');
            drawPileEl.className = 'solitaire-pile draw-pile';
            drawPileEl.addEventListener('click', drawCard);
            deckArea.appendChild(drawPileEl);

            // Create waste pile
            const wastePileEl = document.createElement('div');
            wastePileEl.className = 'solitaire-pile waste-pile';
            deckArea.appendChild(wastePileEl);

            // Create foundation piles
            for (let i = 0; i < 4; i++) {
                const foundationEl = document.createElement('div');
                foundationEl.className = 'solitaire-pile foundation';
                foundationEl.dataset.index = i;
                foundationEl.addEventListener('dragover', e => e.preventDefault());
                foundationEl.addEventListener('drop', dropOnFoundation);
                deckArea.appendChild(foundationEl);
            }

            // Create tableau
            const tableauArea = document.createElement('div');
            tableauArea.className = 'solitaire-tableau';
            table.appendChild(tableauArea);

            for (let i = 0; i < 7; i++) {
                const pileEl = document.createElement('div');
                pileEl.className = 'solitaire-tableau-pile';
                pileEl.dataset.index = i;
                pileEl.addEventListener('dragover', e => e.preventDefault());
                pileEl.addEventListener('drop', dropOnTableau);
                tableauArea.appendChild(pileEl);
            }

            // Deal cards
            deck = createDeck();
            for (let i = 0; i < 7; i++) {
                for (let j = i; j < 7; j++) {
                    const card = deck.pop();
                    if (i === j) card.faceUp = true;
                    tableaus[j].push(card);
                }
            }

            drawPile = deck;
            updateBoard();
        }

        function updateBoard() {
            // Update draw pile
            const drawPileEl = table.querySelector('.draw-pile');
            drawPileEl.innerHTML = '';
            if (drawPile.length > 0) {
                drawPileEl.appendChild(createCardElement({ faceUp: false }));
            }

            // Update waste pile
            const wastePileEl = table.querySelector('.waste-pile');
            wastePileEl.innerHTML = '';
            if (wastePile.length > 0) {
                const card = wastePile[wastePile.length - 1];
                const el = createCardElement(card);
                el.addEventListener('dragstart', dragStart);
                wastePileEl.appendChild(el);
            }

            // Update foundations
            const foundationEls = table.querySelectorAll('.foundation');
            foundationEls.forEach((el, i) => {
                el.innerHTML = '';
                if (foundations[i].length > 0) {
                    const card = foundations[i][foundations[i].length - 1];
                    const cardEl = createCardElement(card);
                    cardEl.addEventListener('dragstart', dragStart);
                    el.appendChild(cardEl);
                }
            });

            // Update tableaus
            const pileEls = table.querySelectorAll('.solitaire-tableau-pile');
            pileEls.forEach((el, i) => {
                el.innerHTML = '';
                tableaus[i].forEach((card, j) => {
                    const cardEl = createCardElement(card);
                    cardEl.style.top = (j * 30) + 'px';
                    if (card.faceUp) {
                        cardEl.addEventListener('dragstart', dragStart);
                    }
                    el.appendChild(cardEl);
                });
            });
        }

        function drawCard() {
            if (!gameActive) return;

            if (drawPile.length === 0) {
                drawPile = wastePile.reverse().map(card => ({ ...card, faceUp: false }));
                wastePile = [];
            } else {
                const card = drawPile.pop();
                card.faceUp = true;
                wastePile.push(card);
                moves++;
                setScore('Moves: ' + moves);
            }

            updateBoard();
        }

        function dragStart(e) {
            if (!gameActive) return;

            const cardEl = e.target.closest('.solitaire-card');
            const pileEl = cardEl.parentElement;

            // Store drag data
            const suit = cardEl.dataset.suit;
            const value = parseInt(cardEl.dataset.value);
            const source = pileEl.classList.contains('waste-pile') ? 'waste' :
                pileEl.classList.contains('foundation') ? 'foundation' :
                    'tableau';
            const pileIndex = pileEl.dataset.index;

            e.dataTransfer.setData('text/plain',
                JSON.stringify({ suit, value, source, pileIndex })
            );
        }

        function canMoveToFoundation(card, foundation) {
            if (foundation.length === 0) {
                return card.value === 1;
            }
            const topCard = foundation[foundation.length - 1];
            return card.suit === topCard.suit && card.value === topCard.value + 1;
        }

        function canMoveToTableau(card, tableau) {
            if (tableau.length === 0) {
                return card.value === 13;
            }
            const topCard = tableau[tableau.length - 1];
            return COLORS[card.suit] !== COLORS[topCard.suit] &&
                card.value === topCard.value - 1;
        }

        function dropOnFoundation(e) {
            e.preventDefault();
            if (!gameActive) return;

            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const foundationIndex = parseInt(e.target.closest('.foundation').dataset.index);
            const foundation = foundations[foundationIndex];

            let card;
            if (data.source === 'waste') {
                card = wastePile.pop();
            } else if (data.source === 'tableau') {
                const tableau = tableaus[data.pileIndex];
                if (tableau[tableau.length - 1].value === data.value) {
                    card = tableau.pop();
                }
            } else if (data.source === 'foundation') {
                const sourceFoundation = foundations[data.pileIndex];
                card = sourceFoundation.pop();
            }

            if (card && canMoveToFoundation(card, foundation)) {
                foundations[foundationIndex].push(card);
                moves++;
                setScore('Moves: ' + moves);

                // Check for win
                if (foundations.every(f => f.length === 13)) {
                    gameActive = false;
                    setTimeout(() => alert('Congratulations! You won in ' + moves + ' moves!'), 100);
                }
            } else if (card) {
                // Return card to source
                if (data.source === 'waste') wastePile.push(card);
                else if (data.source === 'tableau') tableaus[data.pileIndex].push(card);
                else if (data.source === 'foundation') foundations[data.pileIndex].push(card);
            }

            updateBoard();
        }

        function dropOnTableau(e) {
            e.preventDefault();
            if (!gameActive) return;

            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const tableauIndex = parseInt(e.target.closest('.solitaire-tableau-pile').dataset.index);
            const tableau = tableaus[tableauIndex];

            let card;
            if (data.source === 'waste') {
                card = wastePile.pop();
            } else if (data.source === 'tableau') {
                const sourceTableau = tableaus[data.pileIndex];
                if (sourceTableau[sourceTableau.length - 1].value === data.value) {
                    card = sourceTableau.pop();
                    if (sourceTableau.length > 0 && !sourceTableau[sourceTableau.length - 1].faceUp) {
                        sourceTableau[sourceTableau.length - 1].faceUp = true;
                    }
                }
            } else if (data.source === 'foundation') {
                const foundation = foundations[data.pileIndex];
                card = foundation.pop();
            }

            if (card && canMoveToTableau(card, tableau)) {
                tableaus[tableauIndex].push(card);
                moves++;
                setScore('Moves: ' + moves);
            } else if (card) {
                // Return card to source
                if (data.source === 'waste') wastePile.push(card);
                else if (data.source === 'tableau') tableaus[data.pileIndex].push(card);
                else if (data.source === 'foundation') foundations[data.pileIndex].push(card);
            }

            updateBoard();
        }

        setupGame();

        return {
            cleanup() {
                gameActive = false;
            },
            restart() {
                gameActive = false;
                deck = [];
                drawPile = [];
                wastePile = [];
                foundations = [[], [], [], []];
                tableaus = [[], [], [], [], [], [], []];
                moves = 0;
                setScore('Moves: 0');
                setupGame();
                gameActive = true;
            }
        };
    }

    // ---------- Mini Chess ----------
    function buildChess(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Mini Chess</div>
            <div class="score-pill">Turn: White</div>
          </div>
          <div class="chess-board"></div>
          <div style="margin-top:10px;text-align:center;color:#90a4ae" id="chess-status"></div>
        </div>
      `;

        const board = container.querySelector('.chess-board');
        const statusEl = document.getElementById('chess-status');
        let selectedPiece = null;
        let gameActive = true;
        let isWhiteTurn = true;
        let pieces = new Map();

        const PIECE_CHARS = {
            'w_king': 'â™”', 'w_queen': 'â™•', 'w_rook': 'â™–',
            'w_bishop': 'â™—', 'w_knight': 'â™˜', 'w_pawn': 'â™™',
            'b_king': 'â™š', 'b_queen': 'â™›', 'b_rook': 'â™œ',
            'b_bishop': 'â™', 'b_knight': 'â™ž', 'b_pawn': 'â™Ÿ'
        };

        function createBoard() {
            const squares = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    if ((row + col) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }
                    board.appendChild(square);
                    squares.push(square);
                }
            }
            return squares;
        }

        function addPiece(type, color, row, col) {
            const piece = document.createElement('div');
            piece.className = 'chess-piece';
            piece.textContent = PIECE_CHARS[color + '_' + type];
            piece.dataset.type = type;
            piece.dataset.color = color;

            const square = getSquare(row, col);
            square.appendChild(piece);
            pieces.set(piece, { type, color, row, col });

            return piece;
        }

        function setupPieces() {
            // Setup pawns
            for (let col = 0; col < 8; col++) {
                addPiece('pawn', 'w', 6, col);
                addPiece('pawn', 'b', 1, col);
            }

            // Setup other pieces
            const backrow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let col = 0; col < 8; col++) {
                addPiece(backrow[col], 'w', 7, col);
                addPiece(backrow[col], 'b', 0, col);
            }
        }

        function getSquare(row, col) {
            return board.children[row * 8 + col];
        }

        function getPieceAt(row, col) {
            const square = getSquare(row, col);
            return square.querySelector('.chess-piece');
        }

        function isValidMove(piece, toRow, toCol) {
            const pieceData = pieces.get(piece);
            if (!pieceData) return false;

            const { type, color, row, col } = pieceData;
            const targetPiece = getPieceAt(toRow, toCol);

            if (targetPiece && pieces.get(targetPiece).color === color) {
                return false;
            }

            const rowDiff = Math.abs(toRow - row);
            const colDiff = Math.abs(toCol - col);

            switch (type) {
                case 'pawn':
                    const direction = color === 'w' ? -1 : 1;
                    const startRow = color === 'w' ? 6 : 1;

                    // Normal move
                    if (colDiff === 0 && !targetPiece) {
                        if (toRow - row === direction) return true;
                        // First move can be 2 squares
                        if (row === startRow && toRow - row === direction * 2) {
                            const midPiece = getPieceAt(row + direction, col);
                            return !midPiece;
                        }
                    }
                    // Capture
                    if (colDiff === 1 && toRow - row === direction && targetPiece) {
                        return true;
                    }
                    return false;

                case 'rook':
                    if (rowDiff === 0 || colDiff === 0) {
                        const dr = Math.sign(toRow - row);
                        const dc = Math.sign(toCol - col);
                        let r = row + dr, c = col + dc;
                        while (r !== toRow || c !== toCol) {
                            if (getPieceAt(r, c)) return false;
                            r += dr;
                            c += dc;
                        }
                        return true;
                    }
                    return false;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                case 'bishop':
                    if (rowDiff === colDiff) {
                        const dr = Math.sign(toRow - row);
                        const dc = Math.sign(toCol - col);
                        let r = row + dr, c = col + dc;
                        while (r !== toRow) {
                            if (getPieceAt(r, c)) return false;
                            r += dr;
                            c += dc;
                        }
                        return true;
                    }
                    return false;

                case 'queen':
                    if (rowDiff === colDiff || rowDiff === 0 || colDiff === 0) {
                        const dr = Math.sign(toRow - row);
                        const dc = Math.sign(toCol - col);
                        let r = row + dr, c = col + dc;
                        while (r !== toRow || c !== toCol) {
                            if (getPieceAt(r, c)) return false;
                            r += dr;
                            c += dc;
                        }
                        return true;
                    }
                    return false;

                case 'king':
                    return rowDiff <= 1 && colDiff <= 1;
            }

            return false;
        }

        function isKingInCheck(color) {
            let kingPos;
            for (const [piece, data] of pieces) {
                if (data.type === 'king' && data.color === color) {
                    kingPos = { row: data.row, col: data.col };
                    break;
                }
            }

            for (const [piece, data] of pieces) {
                if (data.color !== color && isValidMove(piece, kingPos.row, kingPos.col)) {
                    return true;
                }
            }
            return false;
        }

        function makeAIMove() {
            setTimeout(() => {
                if (!gameActive) return;

                let bestMove = null;
                let bestScore = -Infinity;

                // Simple AI: Evaluate each possible move
                for (const [piece, data] of pieces) {
                    if (data.color === 'b') {
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 8; col++) {
                                if (isValidMove(piece, row, col)) {
                                    // Score the move
                                    const targetPiece = getPieceAt(row, col);
                                    let score = Math.random() * 0.2; // Add randomness

                                    if (targetPiece) {
                                        const targetType = pieces.get(targetPiece).type;
                                        score += {
                                            'pawn': 1,
                                            'knight': 3,
                                            'bishop': 3,
                                            'rook': 5,
                                            'queen': 9,
                                            'king': 0
                                        }[targetType];
                                    }

                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = { piece, row, col };
                                    }
                                }
                            }
                        }
                    }
                }

                if (bestMove) {
                    const target = getPieceAt(bestMove.row, bestMove.col);
                    if (target) target.remove();

                    const pieceData = pieces.get(bestMove.piece);
                    pieces.set(bestMove.piece, {
                        ...pieceData,
                        row: bestMove.row,
                        col: bestMove.col
                    });

                    getSquare(bestMove.row, bestMove.col).appendChild(bestMove.piece);
                    isWhiteTurn = true;
                    setScore('Turn: White');

                    if (isKingInCheck('w')) {
                        statusEl.textContent = 'Check!';
                    } else {
                        statusEl.textContent = '';
                    }
                }
            }, 500);
        }

        function onSquareClick(e) {
            if (!gameActive || !isWhiteTurn) return;

            const square = e.target.closest('.chess-square');
            if (!square) return;

            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = getPieceAt(row, col);

            if (selectedPiece) {
                const pieceData = pieces.get(selectedPiece);

                if (isValidMove(selectedPiece, row, col)) {
                    // Make the move
                    if (piece) piece.remove();

                    pieces.set(selectedPiece, {
                        ...pieceData,
                        row,
                        col
                    });

                    square.appendChild(selectedPiece);
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;

                    // Switch turns
                    isWhiteTurn = false;
                    setScore('Turn: Black');

                    if (isKingInCheck('b')) {
                        statusEl.textContent = 'Check!';
                    } else {
                        statusEl.textContent = '';
                    }

                    makeAIMove();
                } else if (piece && pieces.get(piece).color === 'w') {
                    selectedPiece.classList.remove('selected');
                    piece.classList.add('selected');
                    selectedPiece = piece;
                } else {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }
            } else if (piece && pieces.get(piece).color === 'w') {
                piece.classList.add('selected');
                selectedPiece = piece;
            }
        }

        const squares = createBoard();
        setupPieces();
        board.addEventListener('click', onSquareClick);

        return {
            cleanup() {
                gameActive = false;
                board.removeEventListener('click', onSquareClick);
            },
            restart() {
                gameActive = false;
                board.innerHTML = '';
                pieces.clear();
                selectedPiece = null;
                isWhiteTurn = true;
                setScore('Turn: White');
                statusEl.textContent = '';
                createBoard();
                setupPieces();
                gameActive = true;
            }
        };
    }

    // ---------- Doodle Jump ----------
    function buildDoodle(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Doodle Jump</div>
            <div class="score-pill">Height: 0</div>
          </div>
          <div class="doodle-game"></div>
        </div>
      `;

        const game = container.querySelector('.doodle-game');
        const GRAVITY = 0.4;
        const JUMP_FORCE = -12;
        const PLATFORM_COUNT = 8;

        let score = 0;
        let gameActive = true;
        let platforms = [];
        let player = null;
        let cameraY = 0;

        function createPlatform(x, y) {
            const platform = document.createElement('div');
            platform.className = 'doodle-platform';
            platform.style.left = x + 'px';
            platform.style.top = y + 'px';
            game.appendChild(platform);
            return { el: platform, x, y, width: 60, height: 12 };
        }

        function createPlayer(x, y) {
            const el = document.createElement('div');
            el.className = 'doodle-player';
            game.appendChild(el);
            return {
                el,
                x,
                y,
                width: 40,
                height: 40,
                velocity: { x: 0, y: 0 },
                direction: 1
            };
        }

        function initGame() {
            // Create initial platforms
            for (let i = 0; i < PLATFORM_COUNT; i++) {
                const x = Math.random() * (game.offsetWidth - 60);
                const y = (game.offsetHeight / PLATFORM_COUNT) * i;
                platforms.push(createPlatform(x, y));
            }

            // Create player
            const startPlatform = platforms[0];
            player = createPlayer(
                startPlatform.x + (startPlatform.width - 40) / 2,
                startPlatform.y - 40
            );
        }

        function checkCollisions() {
            if (player.velocity.y > 0) { // Only check when falling
                for (const platform of platforms) {
                    if (player.x + player.width > platform.x &&
                        player.x < platform.x + platform.width &&
                        player.y + player.height > platform.y &&
                        player.y + player.height < platform.y + platform.height) {
                        player.velocity.y = JUMP_FORCE;
                        break;
                    }
                }
            }
        }

        function updatePlayer() {
            // Apply gravity
            player.velocity.y += GRAVITY;

            // Update position
            player.x += player.velocity.x;
            player.y += player.velocity.y;

            // Screen wrapping
            if (player.x + player.width < 0) {
                player.x = game.offsetWidth;
            } else if (player.x > game.offsetWidth) {
                player.x = -player.width;
            }

            // Camera follow
            if (player.y < game.offsetHeight / 2) {
                const diff = game.offsetHeight / 2 - player.y;
                cameraY += diff;
                player.y += diff;

                // Move platforms down
                platforms.forEach(platform => {
                    platform.y += diff;
                    platform.el.style.top = platform.y + 'px';
                });

                // Remove platforms that are too low and create new ones at the top
                platforms = platforms.filter(platform => {
                    if (platform.y > game.offsetHeight) {
                        platform.el.remove();
                        return false;
                    }
                    return true;
                });

                while (platforms.length < PLATFORM_COUNT) {
                    const x = Math.random() * (game.offsetWidth - 60);
                    const y = platforms[0].y - Math.random() * 100 - 50;
                    platforms.unshift(createPlatform(x, y));
                }

                // Update score
                score = Math.floor(cameraY / 100);
                setScore('Height: ' + score);
            }

            // Update player element
            player.el.style.left = player.x + 'px';
            player.el.style.top = player.y + 'px';
            player.el.style.transform = `scaleX(${player.direction})`;

            // Game over if player falls below screen
            if (player.y > game.offsetHeight) {
                gameOver();
            }
        }

        function update() {
            if (!gameActive) return;
            checkCollisions();
            updatePlayer();
            requestAnimationFrame(update);
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Height', score);
        }

        // Controls
        let leftPressed = false;
        let rightPressed = false;

        function updateMovement() {
            player.velocity.x = (rightPressed ? 5 : 0) + (leftPressed ? -5 : 0);
            player.direction = player.velocity.x > 0 ? 1 : (player.velocity.x < 0 ? -1 : player.direction);
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') {
                leftPressed = true;
                updateMovement();
            } else if (e.key === 'ArrowRight') {
                rightPressed = true;
                updateMovement();
            }
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') {
                leftPressed = false;
                updateMovement();
            } else if (e.key === 'ArrowRight') {
                rightPressed = false;
                updateMovement();
            }
        });

        // Touch controls
        let touchStart = null;
        game.addEventListener('touchstart', e => {
            touchStart = e.touches[0].clientX;
        });

        game.addEventListener('touchmove', e => {
            if (touchStart === null) return;
            const diff = e.touches[0].clientX - touchStart;
            player.velocity.x = diff * 0.1;
            player.direction = player.velocity.x > 0 ? 1 : -1;
        });

        game.addEventListener('touchend', () => {
            touchStart = null;
            player.velocity.x = 0;
        });

        initGame();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                if (player) player.el.remove();
                platforms.forEach(p => p.el.remove());
            },
            restart() {
                gameActive = false;
                if (player) player.el.remove();
                platforms.forEach(p => p.el.remove());
                platforms = [];
                player = null;
                score = 0;
                cameraY = 0;
                setScore('Height: 0');
                initGame();
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Speed Racer ----------
    function buildRace(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Speed Racer</div>
            <div class="score-pill">Score: 0</div>
          </div>
          <div class="race-game">
            <div id="race-car" class="race-car"></div>
          </div>
        </div>
      `;

        const game = container.querySelector('.race-game');
        const car = document.getElementById('race-car');
        let score = 0;
        let speed = 5;
        let carX = game.offsetWidth / 2;
        let carY = game.offsetHeight - 80;
        let obstacles = [];
        let gameActive = true;
        let turning = 0;

        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.className = 'race-car';
            obstacle.style.background = '#455a64';
            obstacle.style.width = '30px';
            obstacle.style.height = '50px';

            const lane = Math.floor(Math.random() * 3);
            const x = lane * (game.offsetWidth / 3) + game.offsetWidth / 6;
            obstacle.style.left = x + 'px';
            obstacle.style.top = '-50px';

            game.appendChild(obstacle);
            return { el: obstacle, x, y: -50, speed: 3 + Math.random() * 2 };
        }

        function updateCar() {
            carX = Math.max(0, Math.min(game.offsetWidth - 30, carX + turning * 5));
            car.style.left = carX + 'px';
            car.style.transform = `rotate(${turning * 3}deg)`;
        }

        function update() {
            if (!gameActive) return;

            // Create new obstacles
            if (Math.random() < 0.02) {
                obstacles.push(createObstacle());
            }

            // Update obstacles
            obstacles.forEach((obs, i) => {
                obs.y += obs.speed;
                obs.el.style.top = obs.y + 'px';

                // Check collision
                if (obs.y + 50 > carY && obs.y < carY + 50 &&
                    Math.abs(obs.x - carX) < 30) {
                    gameOver();
                }

                // Remove if off screen
                if (obs.y > game.offsetHeight) {
                    obs.el.remove();
                    obstacles.splice(i, 1);
                    score++;
                    setScore('Score: ' + score);
                    speed = Math.min(10, 5 + score / 20);
                }
            });

            updateCar();
            requestAnimationFrame(update);
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Score', score);
        }

        // Controls
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') turning = -1;
            if (e.key === 'ArrowRight') turning = 1;
        });

        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' && turning === -1) turning = 0;
            if (e.key === 'ArrowRight' && turning === 1) turning = 0;
        });

        // Touch controls
        let touchStartX = 0;
        game.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });

        game.addEventListener('touchmove', e => {
            const touchX = e.touches[0].clientX;
            turning = touchX > touchStartX ? 1 : -1;
        });

        game.addEventListener('touchend', () => {
            turning = 0;
        });

        // Initial position
        car.style.left = carX + 'px';
        car.style.top = carY + 'px';
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                window.removeEventListener('keydown', () => { });
                window.removeEventListener('keyup', () => { });
            },
            restart() {
                obstacles.forEach(obs => obs.el.remove());
                obstacles = [];
                score = 0;
                speed = 5;
                carX = game.offsetWidth / 2;
                turning = 0;
                car.style.left = carX + 'px';
                setScore('Score: 0');
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Fruit Slice ----------
    function buildFruit(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Fruit Slice</div>
            <div class="score-pill">Score: 0</div>
          </div>
          <div class="fruit-game"></div>
        </div>
      `;

        const game = container.querySelector('.fruit-game');
        const fruits = [
            { emoji: 'ðŸŽ', points: 10, color: '#e53935' },
            { emoji: 'ðŸŒ', points: 15, color: '#fdd835' },
            { emoji: 'ðŸŠ', points: 20, color: '#fb8c00' },
            { emoji: 'ðŸ‡', points: 25, color: '#8e24aa' },
            { emoji: 'ðŸ‰', points: 30, color: '#43a047' },
            { emoji: 'ðŸ’£', points: -50, color: '#000000' }
        ];

        let score = 0;
        let gameActive = true;
        let mouseTrail = [];
        let lastTrailTime = 0;
        let activeFruits = [];

        function createFruit() {
            const fruit = fruits[Math.floor(Math.random() * (fruits.length - 1))]; // Exclude bomb from random selection
            const el = document.createElement('div');
            el.className = 'fruit';
            el.style.fontSize = '40px';
            el.textContent = fruit.emoji;

            const startX = Math.random() * (game.offsetWidth - 40);
            const startY = game.offsetHeight + 40;

            el.style.left = startX + 'px';
            el.style.top = startY + 'px';

            game.appendChild(el);

            return {
                el,
                x: startX,
                y: startY,
                velocity: {
                    x: (Math.random() - 0.5) * 8,
                    y: -15 - Math.random() * 5
                },
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 10,
                points: fruit.points,
                color: fruit.color,
                sliced: false
            };
        }

        function createBomb() {
            const bomb = fruits[fruits.length - 1];
            const el = document.createElement('div');
            el.className = 'fruit';
            el.style.fontSize = '40px';
            el.textContent = bomb.emoji;

            const startX = Math.random() * (game.offsetWidth - 40);
            const startY = game.offsetHeight + 40;

            el.style.left = startX + 'px';
            el.style.top = startY + 'px';

            game.appendChild(el);

            return {
                el,
                x: startX,
                y: startY,
                velocity: {
                    x: (Math.random() - 0.5) * 6,
                    y: -12 - Math.random() * 4
                },
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 8,
                points: bomb.points,
                color: bomb.color,
                sliced: false
            };
        }

        function addTrailPoint(x, y) {
            const now = Date.now();
            if (now - lastTrailTime > 50) { // Limit trail point creation
                const trail = document.createElement('div');
                trail.className = 'fruit-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                game.appendChild(trail);
                mouseTrail.push({ el: trail, time: now });
                lastTrailTime = now;
            }
        }

        function updateTrail() {
            const now = Date.now();
            mouseTrail = mouseTrail.filter(point => {
                if (now - point.time > 200) {
                    point.el.remove();
                    return false;
                }
                point.el.style.opacity = 1 - (now - point.time) / 200;
                return true;
            });
        }

        function checkSlice(fruit, x1, y1, x2, y2) {
            if (fruit.sliced) return false;

            const fruitX = fruit.x + 20;
            const fruitY = fruit.y + 20;

            // Line segment intersection check
            const d = ((fruitX - x1) * (y2 - y1) - (fruitY - y1) * (x2 - x1)) /
                Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));

            return Math.abs(d) < 30;
        }

        function update() {
            if (!gameActive) return;

            // Create new fruits
            if (Math.random() < 0.03) {
                activeFruits.push(Math.random() < 0.15 ? createBomb() : createFruit());
            }

            // Update fruits
            activeFruits = activeFruits.filter(fruit => {
                fruit.velocity.y += 0.5; // Gravity
                fruit.x += fruit.velocity.x;
                fruit.y += fruit.velocity.y;
                fruit.rotation += fruit.rotationSpeed;

                fruit.el.style.left = fruit.x + 'px';
                fruit.el.style.top = fruit.y + 'px';
                fruit.el.style.transform = `rotate(${fruit.rotation}deg)`;

                if (fruit.y > game.offsetHeight + 100) {
                    fruit.el.remove();
                    return false;
                }
                return true;
            });

            updateTrail();
            requestAnimationFrame(update);
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Score', score);
        }

        // Mouse/Touch controls
        let lastX = 0, lastY = 0;
        let isSlicing = false;

        function startSlice(x, y) {
            isSlicing = true;
            lastX = x;
            lastY = y;
        }

        function continueSlice(x, y) {
            if (!isSlicing) return;

            addTrailPoint(x, y);

            activeFruits.forEach(fruit => {
                if (checkSlice(fruit, lastX, lastY, x, y)) {
                    fruit.sliced = true;
                    fruit.el.style.opacity = '0.5';
                    score += fruit.points;
                    if (fruit.points < 0) gameOver();
                    setScore('Score: ' + score);
                }
            });

            lastX = x;
            lastY = y;
        }

        function endSlice() {
            isSlicing = false;
        }

        // Mouse events
        game.addEventListener('mousedown', e => {
            const rect = game.getBoundingClientRect();
            startSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        game.addEventListener('mousemove', e => {
            const rect = game.getBoundingClientRect();
            continueSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        game.addEventListener('mouseup', endSlice);
        game.addEventListener('mouseleave', endSlice);

        // Touch events
        game.addEventListener('touchstart', e => {
            const rect = game.getBoundingClientRect();
            const touch = e.touches[0];
            startSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        game.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = game.getBoundingClientRect();
            const touch = e.touches[0];
            continueSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        game.addEventListener('touchend', endSlice);

        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                activeFruits.forEach(f => f.el.remove());
                mouseTrail.forEach(t => t.el.remove());
            },
            restart() {
                activeFruits.forEach(f => f.el.remove());
                mouseTrail.forEach(t => t.el.remove());
                activeFruits = [];
                mouseTrail = [];
                score = 0;
                setScore('Score: 0');
                gameActive = true;
                requestAnimationFrame(update);
            }
        };
    }

    // ---------- Tower Defense ----------
    function buildDefense(container, setScore) {
        container.innerHTML = `
        <div style="max-width:800px;margin:0 auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
            <div style="font-weight:900">Tower Defense</div>
            <div style="display:flex;gap:10px">
              <div class="score-pill">Wave: 1</div>
              <div class="score-pill">Gold: 100</div>
            </div>
          </div>
          <div class="defense-game"></div>
          <div style="margin-top:10px;display:flex;gap:10px;justify-content:center">
            <button class="action-btn" id="buildTower">Build Tower (50g)</button>
            <button class="action-btn" id="upgradeTower">Upgrade Selected (100g)</button>
          </div>
        </div>
      `;

        const game = container.querySelector('.defense-game');
        const buildBtn = document.getElementById('buildTower');
        const upgradeBtn = document.getElementById('upgradeTower');

        let towers = [];
        let enemies = [];
        let bullets = [];
        let gold = 100;
        let wave = 1;
        let gameActive = true;
        let selectedTower = null;
        let path = [];

        // Generate path points
        function generatePath() {
            path = [
                { x: -20, y: 100 },
                { x: 150, y: 100 },
                { x: 150, y: 200 },
                { x: 400, y: 200 },
                { x: 400, y: 100 },
                { x: game.offsetWidth + 20, y: 100 }
            ];
        }

        function createTower(x, y) {
            const tower = document.createElement('div');
            tower.className = 'defense-tower';
            tower.style.left = (x - 20) + 'px';
            tower.style.top = (y - 20) + 'px';
            game.appendChild(tower);

            const newTower = {
                el: tower,
                x: x,
                y: y,
                range: 100,
                damage: 20,
                fireRate: 1,
                lastShot: 0,
                level: 1
            };

            tower.addEventListener('click', () => {
                if (selectedTower) selectedTower.el.style.border = '';
                selectedTower = newTower;
                tower.style.border = '2px solid #fff';
            });

            return newTower;
        }

        function spawnEnemy() {
            const enemy = document.createElement('div');
            enemy.className = 'defense-enemy';
            enemy.style.left = path[0].x + 'px';
            enemy.style.top = path[0].y + 'px';
            game.appendChild(enemy);

            return {
                el: enemy,
                x: path[0].x,
                y: path[0].y,
                health: 100 * (1 + wave * 0.5),
                maxHealth: 100 * (1 + wave * 0.5),
                speed: 1,
                pathIndex: 0,
                value: 10 + wave * 5
            };
        }

        function createBullet(tower, enemy) {
            const bullet = document.createElement('div');
            bullet.className = 'defense-bullet';
            bullet.style.left = tower.x + 'px';
            bullet.style.top = tower.y + 'px';
            game.appendChild(bullet);

            return {
                el: bullet,
                x: tower.x,
                y: tower.y,
                target: enemy,
                speed: 8,
                damage: tower.damage
            };
        }

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                if (!bullet.target.health) {
                    bullet.el.remove();
                    return false;
                }

                const dx = bullet.target.x - bullet.x;
                const dy = bullet.target.y - bullet.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 5) {
                    bullet.target.health -= bullet.damage;
                    bullet.el.remove();
                    return false;
                }

                bullet.x += (dx / dist) * bullet.speed;
                bullet.y += (dy / dist) * bullet.speed;
                bullet.el.style.left = bullet.x + 'px';
                bullet.el.style.top = bullet.y + 'px';

                return true;
            });
        }

        function updateTowers() {
            const now = Date.now();
            towers.forEach(tower => {
                if (now - tower.lastShot > 1000 / tower.fireRate) {
                    enemies.some(enemy => {
                        const dx = enemy.x - tower.x;
                        const dy = enemy.y - tower.y;
                        if (Math.hypot(dx, dy) <= tower.range) {
                            bullets.push(createBullet(tower, enemy));
                            tower.lastShot = now;
                            return true;
                        }
                    });
                }
            });
        }

        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                if (enemy.health <= 0) {
                    enemy.el.remove();
                    gold += enemy.value;
                    updateUI();
                    return false;
                }

                const targetPoint = path[enemy.pathIndex];
                const dx = targetPoint.x - enemy.x;
                const dy = targetPoint.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 2) {
                    enemy.pathIndex++;
                    if (enemy.pathIndex >= path.length) {
                        gameOver();
                        return false;
                    }
                }

                const speed = enemy.speed;
                enemy.x += (dx / dist) * speed;
                enemy.y += (dy / dist) * speed;
                enemy.el.style.left = enemy.x + 'px';
                enemy.el.style.top = enemy.y + 'px';

                // Update health bar
                const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                enemy.el.style.background = `linear-gradient(90deg, #f44336 ${healthPercent}%, #455a64 ${healthPercent}%)`;

                return true;
            });
        }

        function spawnWave() {
            const count = 5 + wave * 2;
            let spawned = 0;

            const spawnInterval = setInterval(() => {
                if (spawned < count && gameActive) {
                    enemies.push(spawnEnemy());
                    spawned++;
                } else {
                    clearInterval(spawnInterval);
                    if (spawned >= count) {
                        setTimeout(() => {
                            if (enemies.length === 0 && gameActive) {
                                wave++;
                                updateUI();
                                spawnWave();
                            }
                        }, 5000);
                    }
                }
            }, 1000);
        }

        function update() {
            if (!gameActive) return;
            updateTowers();
            updateEnemies();
            updateBullets();
            requestAnimationFrame(update);
        }

        function updateUI() {
            const pills = container.querySelectorAll('.score-pill');
            pills[0].textContent = 'Wave: ' + wave;
            pills[1].textContent = 'Gold: ' + gold;
            buildBtn.disabled = gold < 50;
            upgradeBtn.disabled = !selectedTower || gold < 100;
        }

        function gameOver() {
            gameActive = false;
            displayGameOver('Wave', wave);
        }

        // Place tower on click
        game.addEventListener('click', e => {
            const rect = game.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking existing tower
            const clickedTower = towers.find(t =>
                Math.hypot(t.x - x, t.y - y) < 20
            );

            if (clickedTower) {
                if (selectedTower) selectedTower.el.style.border = '';
                selectedTower = clickedTower;
                clickedTower.el.style.border = '2px solid #fff';
            }
        });

        buildBtn.addEventListener('click', () => {
            if (gold >= 50) {
                const rect = game.getBoundingClientRect();
                const placeHandler = e => {
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if too close to path or other towers
                    const tooClose = path.some(point =>
                        Math.hypot(point.x - x, point.y - y) < 50
                    ) || towers.some(tower =>
                        Math.hypot(tower.x - x, tower.y - y) < 50
                    );

                    if (!tooClose) {
                        towers.push(createTower(x, y));
                        gold -= 50;
                        updateUI();
                    }

                    game.removeEventListener('click', placeHandler);
                    buildBtn.disabled = false;
                };

                buildBtn.disabled = true;
                game.addEventListener('click', placeHandler);
            }
        });

        upgradeBtn.addEventListener('click', () => {
            if (selectedTower && gold >= 100) {
                gold -= 100;
                selectedTower.damage *= 1.5;
                selectedTower.range *= 1.2;
                selectedTower.fireRate *= 1.2;
                selectedTower.level++;
                selectedTower.el.style.transform = `scale(${1 + selectedTower.level * 0.1})`;
                updateUI();
            }
        });

        generatePath();
        spawnWave();
        requestAnimationFrame(update);

        return {
            cleanup() {
                gameActive = false;
                towers.forEach(t => t.el.remove());
                enemies.forEach(e => e.el.remove());
                bullets.forEach(b => b.el.remove());
            },
            restart() {
                gameActive = false;
                towers.forEach(t => t.el.remove());
                enemies.forEach(e => e.el.remove());
                bullets.forEach(b => b.el.remove());
                towers = [];
                enemies = [];
                bullets = [];
                gold = 100;
                wave = 1;
                selectedTower = null;
                updateUI();
                gameActive = true;
                spawnWave();
                requestAnimationFrame(update);
            }
        };
    }

    // Show list by default
    showList();

    // cleanup when leaving page
    window.addEventListener('beforeunload', () => { if (current && current.cleanup) current.cleanup(); });

})();
  </script>
  <script>
(function () {
  'use strict';

  const STORAGE_KEY = 'social.feed.posts';
  const VOTE_KEY = 'social.feed.votes';
  const ACCOUNT_KEY = 'social.account';

  const LIMITS = {
    caption: 280,
    fileSize: 5 * 1024 * 1024
  };

  const SAMPLE_POSTS = [
    {
      id: 'sample-1',
      caption: 'Need a chill vibe? Check out this lo-fi beat to keep you coding.',
      author: 'CarpStream Team',
      ownerId: 'carpstream-team',
      createdAt: Date.now() - 1000 * 60 * 45,
      source: { type: 'url', value: 'https://www.youtube.com/watch?v=G1IbRujko-A', kind: 'video' },
      likes: 12,
      dislikes: 1,
      reposts: 4,
      comments: [
        { author: 'Kai', body: 'Love this track!', createdAt: Date.now() - 1000 * 60 * 12 },
        { author: 'Nori', body: 'Saving this for my next coding session.', createdAt: Date.now() - 1000 * 60 * 7 }
      ]
    },
    {
      id: 'sample-2',
      caption: 'Carp spotting on a misty morning.',
      author: 'CarpStream Team',
      ownerId: 'carpstream-team',
      createdAt: Date.now() - 1000 * 60 * 90,
      source: { type: 'url', value: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1200&q=80', kind: 'image' },
      likes: 18,
      dislikes: 0,
      reposts: 5,
      comments: [
        { author: 'Mina', body: 'That reflection is amazing.', createdAt: Date.now() - 1000 * 60 * 70 },
        { author: 'River', body: 'Adding this to my inspiration board.', createdAt: Date.now() - 1000 * 60 * 65 }
      ]
    },
    {
      id: 'sample-3',
      caption: 'Throwback clip that never gets old.',
      author: 'CarpStream Team',
      ownerId: 'carpstream-team',
      createdAt: Date.now() - 1000 * 60 * 160,
      source: { type: 'url', value: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ', kind: 'video' },
      likes: 22,
      dislikes: 3,
      reposts: 8,
      comments: []
    }
  ];

  const ui = {
    viewerMedia: document.getElementById('viewerMedia'),
    viewerEmpty: document.getElementById('viewerEmpty'),
    viewerAuthor: document.getElementById('viewerAuthor'),
    viewerTime: document.getElementById('viewerTime'),
    viewerCaption: document.getElementById('viewerCaption'),
    likeAction: document.getElementById('likeAction'),
    dislikeAction: document.getElementById('dislikeAction'),
    repostAction: document.getElementById('repostAction'),
    shareAction: document.getElementById('shareAction'),
    deleteAction: document.getElementById('deleteAction'),
    fullscreenAction: document.getElementById('fullscreenAction'),
    likeCount: document.getElementById('likeCount'),
    dislikeCount: document.getElementById('dislikeCount'),
    repostCount: document.getElementById('repostCount'),
    commentCount: document.getElementById('commentCount'),
    commentList: document.getElementById('commentList'),
    commentForm: document.getElementById('commentForm'),
    commentInput: document.getElementById('commentInput'),
    postRail: document.getElementById('postRail'),
    todayCount: document.getElementById('todayCount'),
    totalLikes: document.getElementById('totalLikes'),
    openComposer: document.getElementById('openComposer'),
    openComposerRail: document.getElementById('openComposerRail'),
    composerOverlay: document.getElementById('composerOverlay'),
    closeComposer: document.getElementById('closeComposer'),
    cancelComposer: document.getElementById('cancelComposer'),
    composerForm: document.getElementById('composerForm'),
    composerCaption: document.getElementById('composerCaption'),
    composerFile: document.getElementById('composerFile'),
    composerUrl: document.getElementById('composerUrl'),
    composerPreview: document.getElementById('composerPreview'),
    composerThumb: document.getElementById('composerThumb'),
    composerFileName: document.getElementById('composerFileName'),
    clearComposerFile: document.getElementById('clearComposerFile'),
    composerStatus: document.getElementById('composerStatus')
  };

  const state = {
    posts: [],
    votes: {},
    identity: null,
    currentIndex: 0
  };

  function readStorage(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch (error) {
      console.warn('Storage read failed', error);
      return fallback;
    }
  }

  function writeStorage(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.warn('Storage write failed', error);
      return false;
    }
  }

  function loadIdentity() {
    const account = readStorage(ACCOUNT_KEY, null);
    if (!account) return null;
    const id = (account.id || account.email || account.username || '').trim().toLowerCase();
    if (!id) return null;
    const fullName = [account.firstName, account.lastName].filter(Boolean).join(' ').trim();
    const label = account.username || fullName || account.email || 'Member';
    return {
      id,
      label,
      avatar: account.avatar || null
    };
  }

  function normalizeSource(source) {
    if (!source) return null;
    const kind = source.kind || detectKindFromUrl(source.value);
    return {
      type: source.type || 'url',
      value: source.value || null,
      kind: kind || null,
      name: source.name || null
    };
  }

  function resolveLegacySource(post) {
    if (!post) return null;
    if (post.videoUrl) return { type: 'url', value: post.videoUrl, kind: 'video' };
    if (post.imageUrl) return { type: 'url', value: post.imageUrl, kind: 'image' };
    if (post.localVideo) return { type: 'data', value: post.localVideo, kind: 'video' };
    if (post.localImage) return { type: 'data', value: post.localImage, kind: 'image' };
    return null;
  }

  function normalizePost(post) {
    const source = normalizeSource(post.source || resolveLegacySource(post));
    return {
      id: post.id || 'post-' + Date.now() + Math.random().toString(16).slice(2),
      caption: typeof post.caption === 'string' ? post.caption : '',
      author: post.author || 'Member',
      ownerId: post.ownerId || null,
      createdAt: typeof post.createdAt === 'number' ? post.createdAt : Date.now(),
      source,
      likes: typeof post.likes === 'number' ? post.likes : 0,
      dislikes: typeof post.dislikes === 'number' ? post.dislikes : 0,
      reposts: typeof post.reposts === 'number' ? post.reposts : 0,
      comments: Array.isArray(post.comments) ? post.comments.slice(0) : []
    };
  }

  function loadPosts() {
    const stored = readStorage(STORAGE_KEY, null);
    if (Array.isArray(stored) && stored.length) {
      state.posts = stored.map(normalizePost);
    } else {
      state.posts = SAMPLE_POSTS.map(normalizePost);
      persistPosts();
    }
  }

  function persistPosts() {
    const ok = writeStorage(STORAGE_KEY, state.posts);
    if (ok) refreshStats();
    return ok;
  }

  function refreshStats() {
    if (!ui.todayCount && !ui.totalLikes) return;
    const startOfDay = new Date();
    startOfDay.setHours(0, 0, 0, 0);
    const dayStart = startOfDay.getTime();
    let today = 0;
    let totalLikes = 0;
    state.posts.forEach((post) => {
      if (post.createdAt >= dayStart) today += 1;
      totalLikes += post.likes || 0;
    });
    if (ui.todayCount) ui.todayCount.textContent = String(today);
    if (ui.totalLikes) ui.totalLikes.textContent = String(totalLikes);
  }

  function formatTime(timestamp) {
    if (!timestamp) return '';
    const diff = Date.now() - timestamp;
    const minute = 60 * 1000;
    const hour = 60 * minute;
    const day = 24 * hour;
    if (diff < minute) return 'just now';
    if (diff < hour) return Math.floor(diff / minute) + 'm ago';
    if (diff < day) return Math.floor(diff / hour) + 'h ago';
    if (diff < day * 7) return Math.floor(diff / day) + 'd ago';
    const date = new Date(timestamp);
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  }

  function highlightRail() {
    if (!ui.postRail) return;
    const rows = ui.postRail.querySelectorAll('li');
    rows.forEach((row, idx) => {
      row.classList.toggle('active', idx === state.currentIndex);
    });
  }

  function renderQueue() {
    if (!ui.postRail) return;
    ui.postRail.innerHTML = '';
    state.posts.forEach((post, index) => {
      const li = document.createElement('li');
      li.className = 'rail-item' + (index === state.currentIndex ? ' active' : '');

      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'rail-button';
      button.dataset.index = String(index);
      button.addEventListener('click', () => loadPost(index));

      const thumb = document.createElement('div');
      thumb.className = 'rail-thumb';

      if (post.source && post.source.kind === 'image' && post.source.value) {
        const img = document.createElement('img');
        img.src = post.source.value;
        img.alt = post.caption || 'Post image';
        thumb.appendChild(img);
        thumb.classList.add('is-image');
        thumb.setAttribute('aria-label', 'Image post');
      } else if (post.source && post.source.kind === 'video') {
        thumb.textContent = '>';
        thumb.classList.add('is-video');
        thumb.setAttribute('aria-label', 'Video post');
      } else if (post.source && post.source.value) {
        thumb.textContent = '*';
        thumb.classList.add('is-video');
        thumb.setAttribute('aria-label', 'Shared link');
      } else {
        thumb.textContent = 'T';
        thumb.classList.add('is-text');
        thumb.setAttribute('aria-label', 'Text post');
      }

      const body = document.createElement('div');
      body.className = 'rail-body';

      const title = document.createElement('div');
      title.className = 'rail-title';
      title.textContent = post.caption ? post.caption.slice(0, 60) : 'Untitled post';

      const time = document.createElement('div');
      time.className = 'rail-time';
      time.textContent = formatTime(post.createdAt);

      body.appendChild(title);
      body.appendChild(time);
      button.appendChild(thumb);
      button.appendChild(body);
      li.appendChild(button);
      ui.postRail.appendChild(li);
    });
  }

  function setViewerEmpty(message) {
    if (ui.viewerMedia) ui.viewerMedia.innerHTML = '';
    if (ui.viewerEmpty) {
      ui.viewerEmpty.textContent = message;
      ui.viewerEmpty.classList.remove('hidden');
    }
  }

  function hideViewerEmpty() {
    if (ui.viewerEmpty) ui.viewerEmpty.classList.add('hidden');
  }

  function loadPost(index) {
    if (!state.posts.length) {
      setViewerEmpty('No posts yet. Be the first to share something.');
      updateActionButtons(null);
      renderComments(null);
      highlightRail();
      return;
    }

    state.currentIndex = Math.max(0, Math.min(index, state.posts.length - 1));
    const post = state.posts[state.currentIndex];

    if (ui.viewerMedia) {
      ui.viewerMedia.innerHTML = '';
      const media = createMediaElement(post.source);
      if (media) {
        hideViewerEmpty();
        ui.viewerMedia.appendChild(media);
      } else {
        setViewerEmpty('No media attached to this post.');
      }
    }

    if (ui.viewerAuthor) ui.viewerAuthor.textContent = post.author || 'Member';
    if (ui.viewerTime) ui.viewerTime.textContent = formatTime(post.createdAt);
    if (ui.viewerCaption) ui.viewerCaption.textContent = post.caption || '';

    updateActionButtons(post);
    renderComments(post);
    highlightRail();
  }

  function createMediaElement(source) {
    if (!source || !source.value) return null;

    if (source.type === 'data') {
      if (source.kind === 'image') {
        const img = document.createElement('img');
        img.src = source.value;
        img.alt = source.name ? 'Uploaded image ' + source.name : 'Uploaded image';
        img.loading = 'lazy';
        return img;
      }
      if (source.kind === 'video') {
        const video = document.createElement('video');
        video.src = source.value;
        video.controls = true;
        video.preload = 'metadata';
        video.playsInline = true;
        return video;
      }
    }

    if (source.kind === 'image') {
      const img = document.createElement('img');
      img.src = source.value;
      img.alt = 'Shared image';
      img.loading = 'lazy';
      return img;
    }

    if (source.kind === 'video') {
      const youtube = normaliseYouTube(source.value);
      if (youtube) {
        const iframe = document.createElement('iframe');
        iframe.src = youtube;
        iframe.title = 'Shared video';
        iframe.loading = 'lazy';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        return iframe;
      }
      const video = document.createElement('video');
      video.src = source.value;
      video.controls = true;
      video.preload = 'metadata';
      video.playsInline = true;
      return video;
    }

    const iframe = document.createElement('iframe');
    iframe.src = source.value;
    iframe.loading = 'lazy';
    iframe.title = 'Shared link';
    iframe.allowFullscreen = true;
    return iframe;
  }

  function normaliseYouTube(url) {
    try {
      const parsed = new URL(url);
      const host = parsed.hostname.replace(/^www\./, '');
      if (host === 'youtu.be') {
        const id = parsed.pathname.slice(1);
        const query = parsed.searchParams.toString();
        return 'https://www.youtube.com/embed/' + id + (query ? '?' + query : '');
      }
      if (host === 'youtube.com' || host === 'm.youtube.com') {
        if (parsed.searchParams.has('v')) {
          return 'https://www.youtube.com/embed/' + parsed.searchParams.get('v');
        }
        if (parsed.pathname.startsWith('/embed/')) return url;
      }
    } catch (error) {
      return null;
    }
    return null;
  }

  function detectKindFromUrl(url) {
    if (!url || typeof url !== 'string') return null;
    const value = url.toLowerCase();
    if (/(\.png|\.jpe?g|\.gif|\.webp)(\?|$)/.test(value)) return 'image';
    if (/(\.mp4|\.mov|\.webm)(\?|$)/.test(value)) return 'video';
    if (/youtu\.be|youtube\.com/.test(value)) return 'video';
    return null;
  }

  function updateActionButtons(post) {
    const likeBtn = ui.likeAction;
    const dislikeBtn = ui.dislikeAction;
    const repostBtn = ui.repostAction;
    const shareBtn = ui.shareAction;
    const deleteBtn = ui.deleteAction;
    const fullscreenBtn = ui.fullscreenAction;

    if (!post) {
      [likeBtn, dislikeBtn, repostBtn, shareBtn, deleteBtn, fullscreenBtn].forEach((btn) => {
        if (btn) {
          btn.disabled = true;
          btn.classList.remove('is-active');
        }
      });
      if (ui.likeCount) ui.likeCount.textContent = '0';
      if (ui.dislikeCount) ui.dislikeCount.textContent = '0';
      if (ui.repostCount) ui.repostCount.textContent = '0';
      if (ui.commentCount) ui.commentCount.textContent = '0';
      if (ui.commentInput) ui.commentInput.disabled = true;
      if (ui.commentForm) {
        const submit = ui.commentForm.querySelector('button[type="submit"]');
        if (submit) submit.disabled = true;
      }
      return;
    }

    [likeBtn, dislikeBtn, repostBtn, shareBtn].forEach((btn) => {
      if (btn) btn.disabled = false;
    });
    if (fullscreenBtn) fullscreenBtn.disabled = !post.source;
    if (deleteBtn) deleteBtn.disabled = !canDelete(post);
    if (ui.commentInput) ui.commentInput.disabled = false;
    if (ui.commentForm) {
      const submit = ui.commentForm.querySelector('button[type="submit"]');
      if (submit) submit.disabled = false;
    }

    const currentVote = state.votes[post.id] || null;
    if (ui.likeCount) ui.likeCount.textContent = String(post.likes || 0);
    if (ui.dislikeCount) ui.dislikeCount.textContent = String(post.dislikes || 0);
    if (ui.repostCount) ui.repostCount.textContent = String(post.reposts || 0);
    if (ui.commentCount) ui.commentCount.textContent = String(post.comments ? post.comments.length : 0);

    if (likeBtn) likeBtn.classList.toggle('is-active', currentVote === 'like');
    if (dislikeBtn) dislikeBtn.classList.toggle('is-active', currentVote === 'dislike');
  }

  function renderComments(post) {
    if (!ui.commentList) return;
    ui.commentList.innerHTML = '';

    if (!post || !Array.isArray(post.comments) || post.comments.length === 0) {
      const empty = document.createElement('li');
      empty.className = 'comment-empty';
      empty.textContent = post ? 'No comments yet. Start the thread.' : 'No comments to show.';
      ui.commentList.appendChild(empty);
      if (ui.commentCount) ui.commentCount.textContent = '0';
      return;
    }

    post.comments
      .slice(0)
      .sort((a, b) => a.createdAt - b.createdAt)
      .forEach((comment) => {
        const li = document.createElement('li');
        li.className = 'comment';

        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.textContent = (comment.author || 'Guest') + ' - ' + formatTime(comment.createdAt);

        const body = document.createElement('p');
        body.className = 'comment-body';
        body.textContent = comment.body || '';

        li.appendChild(meta);
        li.appendChild(body);
        ui.commentList.appendChild(li);
      });

    if (ui.commentCount) ui.commentCount.textContent = String(post.comments.length);
  }

  function showComposer() {
    if (!ui.composerOverlay) return;
    ui.composerOverlay.classList.remove('hidden');
    document.body.style.overflow = 'hidden';
    resetComposerForm();
    if (ui.composerCaption) ui.composerCaption.focus();
  }

  function hideComposer() {
    if (!ui.composerOverlay) return;
    ui.composerOverlay.classList.add('hidden');
    document.body.style.overflow = '';
  }

  function resetComposerForm() {
    if (ui.composerForm) ui.composerForm.reset();
    if (ui.composerPreview) ui.composerPreview.classList.add('hidden');
    if (ui.composerThumb) {
      ui.composerThumb.style.backgroundImage = '';
      ui.composerThumb.textContent = '';
    }
    if (ui.composerFileName) ui.composerFileName.textContent = '';
    setComposerStatus('');
  }

  function setComposerStatus(message, isError) {
    if (!ui.composerStatus) return;
    ui.composerStatus.textContent = message;
    ui.composerStatus.classList.toggle('error', Boolean(isError));
  }

  async function handleComposerSubmit(event) {
    event.preventDefault();
    if (!ui.composerForm) return;

    setComposerStatus('');

    const caption = ui.composerCaption ? ui.composerCaption.value.trim() : '';
    const file = ui.composerFile && ui.composerFile.files && ui.composerFile.files.length ? ui.composerFile.files[0] : null;
    const url = ui.composerUrl ? ui.composerUrl.value.trim() : '';

    const hasCaption = caption.length > 0;
    const hasFile = Boolean(file);
    const hasUrl = Boolean(url);

    if (!hasCaption && !hasFile && !hasUrl) {
      setComposerStatus('Add a caption or attach media before posting.', true);
      return;
    }

    let source = null;

    if (hasFile) {
      const type = (file.type || '').toLowerCase();
      const isImage = type.startsWith('image/');
      const isVideo = type.startsWith('video/');
      if (!isImage && !isVideo) {
        setComposerStatus('File must be a video or an image.', true);
        return;
      }
      if (file.size > LIMITS.fileSize) {
        setComposerStatus('File too large (max 5MB).', true);
        return;
      }
      try {
        const dataUrl = await readFileAsDataUrl(file);
        source = {
          type: 'data',
          value: dataUrl,
          name: file.name,
          kind: isImage ? 'image' : 'video'
        };
      } catch (error) {
        setComposerStatus('Could not read that file.', true);
        return;
      }
    } else if (hasUrl) {
      try {
        new URL(url);
      } catch (error) {
        setComposerStatus('Enter a valid URL.', true);
        return;
      }
      source = {
        type: 'url',
        value: url,
        kind: detectKindFromUrl(url)
      };
    }

    const identity = state.identity;
    const newPost = normalizePost({
      id: 'post-' + Date.now(),
      caption,
      author: identity ? identity.label : 'Guest',
      ownerId: identity ? identity.id : null,
      createdAt: Date.now(),
      source,
      likes: 0,
      dislikes: 0,
      reposts: 0,
      comments: []
    });

    state.posts.unshift(newPost);
    if (!persistPosts()) {
      state.posts.shift();
      setComposerStatus('Could not save that post. Try a smaller file or clear space.', true);
      return;
    }

    renderQueue();
    loadPost(0);
    resetComposerForm();
    hideComposer();
  }

  function handleComposerFileChange() {
    const file = ui.composerFile && ui.composerFile.files && ui.composerFile.files.length ? ui.composerFile.files[0] : null;
    if (!file) {
      if (ui.composerPreview) ui.composerPreview.classList.add('hidden');
      if (ui.composerFileName) ui.composerFileName.textContent = '';
      if (ui.composerThumb) {
        ui.composerThumb.style.backgroundImage = '';
        ui.composerThumb.textContent = '';
      }
      return;
    }

    if (ui.composerPreview) ui.composerPreview.classList.remove('hidden');
    if (ui.composerFileName) ui.composerFileName.textContent = file.name;

    if (!ui.composerThumb) return;

    if (file.type && file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = () => {
        ui.composerThumb.style.backgroundImage = 'url(' + reader.result + ')';
        ui.composerThumb.textContent = '';
      };
      reader.readAsDataURL(file);
    } else {
      ui.composerThumb.style.backgroundImage = '';
      ui.composerThumb.textContent = '>';
    }
  }

  function handleClearComposerFile() {
    if (ui.composerFile) ui.composerFile.value = '';
    if (ui.composerPreview) ui.composerPreview.classList.add('hidden');
    if (ui.composerFileName) ui.composerFileName.textContent = '';
    if (ui.composerThumb) {
      ui.composerThumb.style.backgroundImage = '';
      ui.composerThumb.textContent = '';
    }
    setComposerStatus('');
  }

  function handleCommentSubmit(event) {
    event.preventDefault();
    if (!ui.commentInput) return;
    const post = state.posts[state.currentIndex];
    if (!post) return;
    const value = ui.commentInput.value.trim();
    if (!value) return;
    if (!Array.isArray(post.comments)) post.comments = [];
    post.comments.push({
      author: state.identity ? state.identity.label : 'Guest',
      body: value,
      createdAt: Date.now()
    });
    if (!persistPosts()) {
      post.comments.pop();
      return;
    }
    ui.commentInput.value = '';
    renderComments(post);
    updateActionButtons(post);
  }

  function applyVote(post, type) {
    const current = state.votes[post.id] || null;
    if (current === type) {
      if (type === 'like' && post.likes > 0) post.likes -= 1;
      if (type === 'dislike' && post.dislikes > 0) post.dislikes -= 1;
      delete state.votes[post.id];
    } else {
      if (current === 'like' && post.likes > 0) post.likes -= 1;
      if (current === 'dislike' && post.dislikes > 0) post.dislikes -= 1;
      if (type === 'like') post.likes += 1;
      if (type === 'dislike') post.dislikes += 1;
      state.votes[post.id] = type;
    }
    writeStorage(VOTE_KEY, state.votes);
    persistPosts();
    updateActionButtons(post);
  }

  function handleRepost(post) {
    post.reposts = (post.reposts || 0) + 1;
    persistPosts();
    updateActionButtons(post);
  }

  function handleShare(post) {
    const fragments = [];
    if (post.caption) fragments.push(post.caption);
    if (post.source && post.source.value) fragments.push(post.source.value);
    const payload = fragments.join('\n');

    if (navigator.share) {
      navigator
        .share({
          title: 'CarpStream post',
          text: post.caption || 'Check out this CarpStream post',
          url: post.source && post.source.type === 'url' ? post.source.value : window.location.href
        })
        .catch((error) => {
          if (error && error.name !== 'AbortError') console.warn('Share cancelled', error);
        });
      return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(payload).then(
        () => window.alert('Post copied to clipboard.'),
        () => window.prompt('Copy this post link:', payload)
      );
      return;
    }

    window.prompt('Copy this post link:', payload);
  }

  function handleDelete(post) {
    if (!post) return;
    if (!canDelete(post)) {
      window.alert('You can only delete your own posts.');
      return;
    }
    if (!window.confirm('Delete this post? This cannot be undone.')) return;
    const index = state.posts.findIndex((item) => item.id === post.id);
    if (index === -1) return;
    state.posts.splice(index, 1);
    persistPosts();
    renderQueue();
    const nextIndex = state.posts.length ? Math.min(index, state.posts.length - 1) : 0;
    loadPost(nextIndex);
  }

  function canDelete(post) {
    if (!post) return false;
    if (!state.identity) return false;
    if (!post.ownerId) return false;
    return post.ownerId === state.identity.id;
  }

  function openFullscreen(node) {
    if (!node) return;
    if (node.requestFullscreen) {
      node.requestFullscreen().catch(() => {});
    }
  }

  function handleFullscreen() {
    const post = state.posts[state.currentIndex];
    if (!post || !ui.viewerMedia) return;
    const target = ui.viewerMedia.querySelector('video, img, iframe');
    if (target) openFullscreen(target);
  }

  function bindEvents() {
    if (ui.openComposer) ui.openComposer.addEventListener('click', showComposer);
    if (ui.openComposerRail) ui.openComposerRail.addEventListener('click', showComposer);
    if (ui.closeComposer) ui.closeComposer.addEventListener('click', hideComposer);
    if (ui.cancelComposer) ui.cancelComposer.addEventListener('click', hideComposer);
    if (ui.clearComposerFile) ui.clearComposerFile.addEventListener('click', handleClearComposerFile);
    if (ui.composerFile) ui.composerFile.addEventListener('change', handleComposerFileChange);
    if (ui.composerForm) ui.composerForm.addEventListener('submit', handleComposerSubmit);
    if (ui.commentForm) ui.commentForm.addEventListener('submit', handleCommentSubmit);

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && ui.composerOverlay && !ui.composerOverlay.classList.contains('hidden')) {
        hideComposer();
      }
    });

    if (ui.likeAction) ui.likeAction.addEventListener('click', () => {
      const post = state.posts[state.currentIndex];
      if (!post) return;
      applyVote(post, 'like');
    });

    if (ui.dislikeAction) ui.dislikeAction.addEventListener('click', () => {
      const post = state.posts[state.currentIndex];
      if (!post) return;
      applyVote(post, 'dislike');
    });

    if (ui.repostAction) ui.repostAction.addEventListener('click', () => {
      const post = state.posts[state.currentIndex];
      if (!post) return;
      handleRepost(post);
    });

    if (ui.shareAction) ui.shareAction.addEventListener('click', () => {
      const post = state.posts[state.currentIndex];
      if (!post) return;
      handleShare(post);
    });

    if (ui.deleteAction) ui.deleteAction.addEventListener('click', () => {
      const post = state.posts[state.currentIndex];
      if (!post) return;
      handleDelete(post);
    });

    if (ui.fullscreenAction) ui.fullscreenAction.addEventListener('click', handleFullscreen);
  }

  function readFileAsDataUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(file);
    });
  }

  function init() {
    state.identity = loadIdentity();
    state.votes = loadVotes();
    loadPosts();
    bindEvents();
    refreshStats();
    renderQueue();
    loadPost(0);
  }

  function loadVotes() {
    const stored = readStorage(VOTE_KEY, {});
    return stored && typeof stored === 'object' ? stored : {};
  }

  init();
})();
  </script>
  <script>
(function () {
  const STORAGE_KEYS = {
    profile: 'settings.profile',
    privacy: 'settings.privacy',
    appearance: 'settings.appearance',
    security: 'settings.security',
    offline: 'settings.offline'
  };

  const ui = {
    profileForm: document.getElementById('profileForm'),
    profileName: document.getElementById('profileName'),
    profileEmail: document.getElementById('profileEmail'),
    profileStatus: document.getElementById('profileStatus'),
    profileNote: document.getElementById('profileNote'),

    privacyForm: document.getElementById('privacyForm'),
    privacyDiscoverable: document.getElementById('privacyDiscoverable'),
    privacyPublicFeed: document.getElementById('privacyPublicFeed'),
    privacyRoomInvites: document.getElementById('privacyRoomInvites'),
    privacyNote: document.getElementById('privacyNote'),

    appearanceForm: document.getElementById('appearanceForm'),
    themeChoice: document.getElementById('themeChoice'),
    appearanceAnimations: document.getElementById('appearanceAnimations'),
    appearanceHighContrast: document.getElementById('appearanceHighContrast'),
    appearanceNote: document.getElementById('appearanceNote'),

    securityForm: document.getElementById('securityForm'),
    currentPassword: document.getElementById('currentPassword'),
    newPassword: document.getElementById('newPassword'),
    confirmPassword: document.getElementById('confirmPassword'),
    securityNote: document.getElementById('securityNote'),

    refreshOffline: document.getElementById('refreshOffline'),
    clearOffline: document.getElementById('clearOffline'),
    exportData: document.getElementById('exportData'),
    storageNote: document.getElementById('storageNote'),
    offlineUpdated: document.getElementById('offlineUpdated')
  };

  const profileData = load(STORAGE_KEYS.profile, {
    name: '',
    email: '',
    status: ''
  });

  const privacyData = load(STORAGE_KEYS.privacy, {
    discoverable: true,
    publicFeed: true,
    allowInvites: true
  });

  const appearanceData = load(STORAGE_KEYS.appearance, {
    theme: 'ocean',
    animations: true,
    highContrast: false
  });

  const securityData = load(STORAGE_KEYS.security, {
    password: '',
    updatedAt: null
  });

  const offlineData = load(STORAGE_KEYS.offline, {
    lastRefresh: null
  });

  hydrateProfile();
  hydratePrivacy();
  hydrateAppearance();
  hydrateOffline();

  if (ui.profileForm) {
    ui.profileForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const nextProfile = {
        name: (ui.profileName.value || '').trim(),
        email: (ui.profileEmail.value || '').trim(),
        status: (ui.profileStatus.value || '').trim()
      };
      save(STORAGE_KEYS.profile, nextProfile);
      setNote(ui.profileNote, 'Profile saved.');
      trySyncAccount(nextProfile);
    });
  }

  if (ui.privacyForm) {
    ui.privacyForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const nextPrivacy = {
        discoverable: Boolean(ui.privacyDiscoverable.checked),
        publicFeed: Boolean(ui.privacyPublicFeed.checked),
        allowInvites: Boolean(ui.privacyRoomInvites.checked)
      };
      save(STORAGE_KEYS.privacy, nextPrivacy);
      setNote(ui.privacyNote, 'Privacy settings updated.');
    });
  }

  if (ui.appearanceForm) {
    ui.appearanceForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const nextAppearance = {
        theme: ui.themeChoice.value || 'ocean',
        animations: Boolean(ui.appearanceAnimations.checked),
        highContrast: Boolean(ui.appearanceHighContrast.checked)
      };
      save(STORAGE_KEYS.appearance, nextAppearance);
      applyAppearance(nextAppearance);
      setNote(ui.appearanceNote, 'Appearance saved.');
    });
  }

  if (ui.securityForm) {
    ui.securityForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const current = ui.currentPassword.value;
      const next = ui.newPassword.value;
      const confirm = ui.confirmPassword.value;
      if (!next || next.length < 6) {
        setNote(ui.securityNote, 'Password must be at least 6 characters.');
        return;
      }
      if (next !== confirm) {
        setNote(ui.securityNote, 'Passwords do not match.');
        return;
      }
      if (securityData.password) {
        const match = comparePasswords(current, securityData.password);
        if (!match) {
          setNote(ui.securityNote, 'Current password is incorrect.');
          return;
        }
      }
      const encoded = encodePassword(next);
      securityData.password = encoded;
      securityData.updatedAt = Date.now();
      save(STORAGE_KEYS.security, securityData);
      ui.currentPassword.value = '';
      ui.newPassword.value = '';
      ui.confirmPassword.value = '';
      setNote(ui.securityNote, 'Password updated successfully.');
    });
  }

  if (ui.refreshOffline) {
    ui.refreshOffline.addEventListener('click', async () => {
      setNote(ui.storageNote, 'Refreshing offline cacheâ€¦');
      try {
        await updateServiceWorker();
        offlineData.lastRefresh = Date.now();
        save(STORAGE_KEYS.offline, offlineData);
        hydrateOffline();
        setNote(ui.storageNote, 'Offline cache refreshed.');
      } catch (err) {
        console.error(err);
        setNote(ui.storageNote, 'Could not refresh cache.');
      }
    });
  }

  if (ui.clearOffline) {
    ui.clearOffline.addEventListener('click', async () => {
      setNote(ui.storageNote, 'Clearing cached dataâ€¦');
      try {
        if ('caches' in window) {
          const keys = await caches.keys();
          await Promise.all(keys.map((key) => caches.delete(key)));
        }
        offlineData.lastRefresh = null;
        save(STORAGE_KEYS.offline, offlineData);
        hydrateOffline();
        setNote(ui.storageNote, 'Offline cache cleared.');
      } catch (err) {
        console.error(err);
        setNote(ui.storageNote, 'Failed to clear cache.');
      }
    });
  }

  if (ui.exportData) {
    ui.exportData.addEventListener('click', () => {
      const payload = {
        profile: load(STORAGE_KEYS.profile, {}),
        privacy: load(STORAGE_KEYS.privacy, {}),
        appearance: load(STORAGE_KEYS.appearance, {}),
        security: { updatedAt: securityData.updatedAt ? new Date(securityData.updatedAt).toISOString() : null },
        offline: load(STORAGE_KEYS.offline, {})
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'carp-settings-export.json';
      document.body.appendChild(link);
      link.click();
      requestAnimationFrame(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      });
      setNote(ui.storageNote, 'Export file downloaded.');
    });
  }

  function hydrateProfile() {
    if (!ui.profileName) return;
    ui.profileName.value = profileData.name || '';
    ui.profileEmail.value = profileData.email || '';
    ui.profileStatus.value = profileData.status || '';
  }

  function hydratePrivacy() {
    if (!ui.privacyForm) return;
    ui.privacyDiscoverable.checked = Boolean(privacyData.discoverable);
    ui.privacyPublicFeed.checked = Boolean(privacyData.publicFeed);
    ui.privacyRoomInvites.checked = Boolean(privacyData.allowInvites);
  }

  function hydrateAppearance() {
    if (!ui.appearanceForm) return;
    ui.themeChoice.value = appearanceData.theme || 'ocean';
    ui.appearanceAnimations.checked = Boolean(appearanceData.animations);
    ui.appearanceHighContrast.checked = Boolean(appearanceData.highContrast);
    applyAppearance(appearanceData);
  }

  function hydrateOffline() {
    if (!ui.offlineUpdated) return;
    ui.offlineUpdated.textContent = offlineData.lastRefresh
      ? new Date(offlineData.lastRefresh).toLocaleString()
      : 'never';
  }

  function applyAppearance(prefs) {
    const body = document.body;
    if (!body) return;
    body.dataset.theme = prefs.theme || 'ocean';
    body.dataset.animations = prefs.animations ? 'on' : 'off';
    body.dataset.contrast = prefs.highContrast ? 'high' : 'normal';
  }

  function updateServiceWorker() {
    if (!('serviceWorker' in navigator)) return Promise.resolve();
    return navigator.serviceWorker.getRegistration()
      .then((registration) => {
        if (!registration) return navigator.serviceWorker.register('sw.js');
        return registration.update();
      });
  }

  function trySyncAccount(profile) {
    try {
      const storage = localStorage.getItem('social.account');
      if (!storage) return;
      const data = JSON.parse(storage);
      if (profile.name) data.username = profile.name;
      if (profile.email) data.email = profile.email;
      localStorage.setItem('social.account', JSON.stringify(data));
    } catch (err) {
      console.warn('Unable to sync account', err);
    }
  }

  function setNote(element, message) {
    if (!element) return;
    element.textContent = message;
    element.classList.add('flash');
    setTimeout(() => element.classList.remove('flash'), 1200);
  }

  function load(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch (err) {
      console.error('settings load failed', key, err);
      return fallback;
    }
  }

  function save(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (err) {
      console.error('settings save failed', key, err);
    }
  }

  function encodePassword(raw) {
    return btoa(unescape(encodeURIComponent(raw)));
  }

  function comparePasswords(raw, encoded) {
    if (!encoded) return false;
    return encodePassword(raw) === encoded;
  }
})();
  </script>
  <script>
(function () {
  const STATUS = document.getElementById('statusMessage');
  const downloadBtn = document.getElementById('downloadZip');
  const openBtn = document.getElementById('openOffline');

  const FILES_TO_PACKAGE = [
    'index.html',
    'account.html',
    'carpai.html',
    'carpai.js',
    'carpai.css',
    'carpfish.html',
    'settings.html',
    'social.html',
    'social.js',
    'styles.css',
    'scripts.js',
    'offline.js',
    'download.js',
    'download.html',
    'chats.html',
    'chats.js',
    'settings.js',
    'sw.js'
  ];

  let building = false;

  function setStatus(message) {
    if (STATUS) {
      STATUS.textContent = message;
    }
  }

  function logError(err) {
    console.error(err);
    setStatus('Something went wrong while building the offline package.');
  }

  openBtn.addEventListener('click', () => {
    window.location.href = 'index.html#offline';
  });

  downloadBtn.addEventListener('click', () => {
    if (!building) {
      createOfflineBundle();
    }
  });

  const textEncoder = new TextEncoder();
  const crcTable = (() => {
    const table = new Uint32Array(256);
    for (let index = 0; index < 256; index += 1) {
      let c = index;
      for (let k = 0; k < 8; k += 1) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[index] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes) {
    let crc = 0 ^ (-1);
    for (let i = 0; i < bytes.length; i += 1) {
      const byte = bytes[i];
      crc = (crc >>> 8) ^ crcTable[(crc ^ byte) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  }

  function toDosDateTime(date) {
    const year = date.getFullYear() - 1980;
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = Math.floor(date.getSeconds() / 2);
    const dosTime = (hours << 11) | (minutes << 5) | seconds;
    const dosDate = (year << 9) | (month << 5) | day;
    return { dosTime, dosDate };
  }

  class ZipBuilder {
    constructor() {
      this.files = [];
    }

    addFile(name, data) {
      const nameBytes = textEncoder.encode(name);
      const crc = crc32(data);
      const timestamp = toDosDateTime(new Date());
      this.files.push({
        name,
        nameBytes,
        data,
        crc,
        modTime: timestamp.dosTime,
        modDate: timestamp.dosDate
      });
    }

    build() {
      let localSize = 0;
      let centralSize = 0;
      this.files.forEach((file) => {
        localSize += 30 + file.nameBytes.length + file.data.length;
        centralSize += 46 + file.nameBytes.length;
      });

      const totalSize = localSize + centralSize + 22;
      const output = new Uint8Array(totalSize);
      let offset = 0;

      this.files.forEach((file) => {
        file.localOffset = offset;
        offset = this.writeLocalHeader(output, offset, file);
      });

      const centralStart = offset;
      this.files.forEach((file) => {
        offset = this.writeCentralDirectoryRecord(output, offset, file);
      });

      const centralSizeFinal = offset - centralStart;
      this.writeEndOfCentralDirectory(output, offset, centralSizeFinal, centralStart, this.files.length);

      return output.buffer;
    }

    writeLocalHeader(buffer, offset, file) {
      offset = writeUint32(buffer, offset, 0x04034B50);
      offset = writeUint16(buffer, offset, 20);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, file.modTime);
      offset = writeUint16(buffer, offset, file.modDate);
      offset = writeUint32(buffer, offset, file.crc);
      offset = writeUint32(buffer, offset, file.data.length);
      offset = writeUint32(buffer, offset, file.data.length);
      offset = writeUint16(buffer, offset, file.nameBytes.length);
      offset = writeUint16(buffer, offset, 0);
      buffer.set(file.nameBytes, offset);
      offset += file.nameBytes.length;
      buffer.set(file.data, offset);
      offset += file.data.length;
      return offset;
    }

    writeCentralDirectoryRecord(buffer, offset, file) {
      offset = writeUint32(buffer, offset, 0x02014B50);
      offset = writeUint16(buffer, offset, 0x0014);
      offset = writeUint16(buffer, offset, 20);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, file.modTime);
      offset = writeUint16(buffer, offset, file.modDate);
      offset = writeUint32(buffer, offset, file.crc);
      offset = writeUint32(buffer, offset, file.data.length);
      offset = writeUint32(buffer, offset, file.data.length);
      offset = writeUint16(buffer, offset, file.nameBytes.length);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint32(buffer, offset, 0);
      offset = writeUint32(buffer, offset, file.localOffset);
      buffer.set(file.nameBytes, offset);
      offset += file.nameBytes.length;
      return offset;
    }

    writeEndOfCentralDirectory(buffer, offset, centralSize, centralStart, fileCount) {
      offset = writeUint32(buffer, offset, 0x06054B50);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, 0);
      offset = writeUint16(buffer, offset, fileCount);
      offset = writeUint16(buffer, offset, fileCount);
      offset = writeUint32(buffer, offset, centralSize);
      offset = writeUint32(buffer, offset, centralStart);
      writeUint16(buffer, offset, 0);
    }
  }

  function writeUint16(buffer, offset, value) {
    buffer[offset] = value & 0xFF;
    buffer[offset + 1] = (value >>> 8) & 0xFF;
    return offset + 2;
  }

  function writeUint32(buffer, offset, value) {
    buffer[offset] = value & 0xFF;
    buffer[offset + 1] = (value >>> 8) & 0xFF;
    buffer[offset + 2] = (value >>> 16) & 0xFF;
    buffer[offset + 3] = (value >>> 24) & 0xFF;
    return offset + 4;
  }

  async function fetchAsBytes(path) {
    const response = await fetch(path, { cache: 'no-cache' });
    if (!response.ok) {
      throw new Error(`Failed to fetch ${path} (${response.status})`);
    }
    const buffer = await response.arrayBuffer();
    return new Uint8Array(buffer);
  }

  async function createOfflineBundle() {
    building = true;
    downloadBtn.disabled = true;
    setStatus('Building offline packageâ€¦');
    try {
      const zip = new ZipBuilder();
      for (let i = 0; i < FILES_TO_PACKAGE.length; i += 1) {
        const filePath = FILES_TO_PACKAGE[i];
        setStatus(`Packing ${filePath}â€¦`);
        const bytes = await fetchAsBytes(filePath);
        zip.addFile(filePath, bytes);
      }

      const blob = new Blob([zip.build()], { type: 'application/zip' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'carp-offline.zip';
      document.body.appendChild(link);
      link.click();
      requestAnimationFrame(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      });
      setStatus('All set! Your offline copy is downloaded.');
    } catch (error) {
      logError(error);
      downloadBtn.disabled = false;
    } finally {
      building = false;
    }
  }

  window.addEventListener('load', () => {
    setTimeout(() => {
      if (!building) {
        createOfflineBundle();
      }
    }, 600);
  });
})();
  </script>
  <script>
(function () {
  const STORAGE = {
    rooms: 'chat.rooms',
    members: 'chat.memberships',
    messages: 'chat.messages',
    profile: 'chat.profile'
  };

  const DEFAULT_ROOMS = [
    {
      id: 'public-lounge',
      name: 'Main Dock',
      type: 'public',
      description: 'Welcome everyone! Say hi and drop your latest catch.',
      inviteCode: '',
      createdBy: 'system',
      peers: ['FinMaster', 'RiverRuler', 'TackleBox42']
    },
    {
      id: 'public-gaming',
      name: 'Arcade Bay',
      type: 'public',
      description: 'Looking for players? Talk about CarpFish and other games here.',
      inviteCode: '',
      createdBy: 'system',
      peers: ['PixelPike', 'TurboGill', 'CaptainLag']
    },
    {
      id: 'public-news',
      name: 'Update Buoy',
      type: 'public',
      description: 'Site updates, sneak peeks, and beta chatter.',
      inviteCode: '',
      createdBy: 'system',
      peers: ['Mod-Carp', 'BetaBuddy']
    }
  ];

  const MAX_IMAGE_BYTES = 512 * 1024;

  function load(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch (err) {
      console.error('chat storage load failed', key, err);
      return fallback;
    }
  }

  function save(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (err) {
      console.error('chat storage save failed', key, err);
    }
  }

  function resolveUsername() {
    try {
      const account = localStorage.getItem('social.account');
      if (account) {
        const parsed = JSON.parse(account);
        if (parsed && parsed.username) return parsed.username;
      }
    } catch (err) {
      console.warn('Failed to read social account', err);
    }
    const stored = load(STORAGE.profile, null);
    if (stored && stored.name) return stored.name;
    const name = `Guest${Math.floor(Math.random() * 900 + 100)}`;
    save(STORAGE.profile, { name });
    return name;
  }

  let rooms = load(STORAGE.rooms, []);
  const roomMap = new Map();
  rooms.forEach((room) => roomMap.set(room.id, room));

  DEFAULT_ROOMS.forEach((room) => {
    if (!roomMap.has(room.id)) {
      rooms.push(room);
      roomMap.set(room.id, room);
    }
  });

  save(STORAGE.rooms, rooms);

  const membership = new Set(load(STORAGE.members, []));
  DEFAULT_ROOMS.forEach((room) => {
    if (!membership.has(room.id)) {
      membership.add(room.id);
    }
  });
  persistMembership();

  const messages = load(STORAGE.messages, {});
  DEFAULT_ROOMS.forEach((room) => {
    if (!messages[room.id]) {
      messages[room.id] = [
        {
          id: `${room.id}-welcome`,
          author: room.peers?.[0] || 'Mod-Carp',
          text: 'Welcome aboard! Drop a message to keep the chat flowing.',
          ts: Date.now() - 1000 * 60 * 5
        }
      ];
    }
  });
  save(STORAGE.messages, messages);

  const profileName = resolveUsername();
  const state = {
    activeRoomId: null,
    pendingImage: null,
    pendingImageName: ''
  };

  const ui = {
    profileChip: document.getElementById('profileChip'),
    publicRoomList: document.getElementById('publicRoomList'),
    privateRoomList: document.getElementById('privateRoomList'),
    createRoomForm: document.getElementById('createRoomForm'),
    joinForm: document.getElementById('joinRoomForm'),
    codeLabel: document.getElementById('codeLabel'),
    roomTemplate: document.getElementById('roomTemplate'),
    messageTemplate: document.getElementById('messageTemplate'),
    memberTemplate: document.getElementById('memberTemplate'),
    roomTitle: document.getElementById('roomTitle'),
    roomMeta: document.getElementById('roomMeta'),
    roomTypePill: document.getElementById('roomTypePill'),
    chatLog: document.getElementById('chatLog'),
    messageForm: document.getElementById('messageForm'),
    messageInput: document.getElementById('messageInput'),
    pickImage: document.getElementById('pickImage'),
    messageFile: document.getElementById('messageFile'),
    imagePreview: document.getElementById('imagePreview'),
    imagePreviewImg: document.getElementById('imagePreviewImg'),
    imagePreviewName: document.getElementById('imagePreviewName'),
    clearImage: document.getElementById('clearImage'),
    leaveRoomBtn: document.getElementById('leaveRoomBtn'),
    memberList: document.getElementById('memberList'),
    refreshMembers: document.getElementById('refreshMembers'),
    inviteBlock: document.getElementById('inviteCodeBlock'),
    inviteValue: document.getElementById('inviteCodeValue'),
    copyInvite: document.getElementById('copyInvite'),
    activeRoom: document.getElementById('activeRoom')
  };

  if (ui.profileChip) {
    ui.profileChip.textContent = profileName;
  }
  ui.sendButton = ui.messageForm ? ui.messageForm.querySelector('button[type="submit"]') : null;

  if (ui.createRoomForm) {
    ui.createRoomForm.addEventListener('change', (event) => {
      if (event.target && event.target.id === 'newRoomType') {
        const isPrivate = event.target.value === 'private';
        togglePrivateFields(isPrivate);
      }
    });
  }

  if (ui.createRoomForm) {
    ui.createRoomForm.addEventListener('submit', handleCreateRoom);
  }

  if (ui.joinForm) {
    ui.joinForm.addEventListener('submit', handleJoinCode);
  }

  if (ui.messageForm) {
    ui.messageForm.addEventListener('submit', handleSendMessage);
  }

  if (ui.pickImage && ui.messageFile) {
    ui.pickImage.addEventListener('click', () => ui.messageFile.click());
  }

  if (ui.messageFile) {
    ui.messageFile.addEventListener('change', handleImageSelection);
  }

  if (ui.clearImage) {
    ui.clearImage.addEventListener('click', () => {
      clearPendingImage();
      if (ui.messageFile) {
        ui.messageFile.value = '';
      }
    });
  }

  if (ui.leaveRoomBtn) {
    ui.leaveRoomBtn.addEventListener('click', () => {
      if (!state.activeRoomId) return;
      membership.delete(state.activeRoomId);
      persistMembership();
      setActiveRoom(null);
      renderRooms();
    });
  }

  if (ui.refreshMembers) {
    ui.refreshMembers.addEventListener('click', () => {
      if (!state.activeRoomId) return;
      renderMembers(roomMap.get(state.activeRoomId));
    });
  }

  if (ui.copyInvite) {
    ui.copyInvite.addEventListener('click', () => {
      const code = ui.inviteValue?.textContent;
      if (!code) return;
      navigator.clipboard?.writeText(code)
        .then(() => showStatus(`Invite code ${code} copied!`))
        .catch(() => showStatus('Failed to copy invite code.'));
    });
  }

  function showStatus(message) {
    if (!ui.profileChip) return;
    ui.profileChip.textContent = message;
    setTimeout(() => {
      ui.profileChip.textContent = profileName;
    }, 3000);
  }

  function updateImagePreview() {
    if (!ui.imagePreview || !ui.imagePreviewImg || !ui.imagePreviewName) return;
    if (state.pendingImage) {
      ui.imagePreview.classList.remove('hidden');
      ui.imagePreviewImg.src = state.pendingImage;
      ui.imagePreviewName.textContent = state.pendingImageName || 'image';
    } else {
      ui.imagePreview.classList.add('hidden');
      ui.imagePreviewImg.removeAttribute('src');
      ui.imagePreviewName.textContent = '';
    }
  }

  function clearPendingImage() {
    state.pendingImage = null;
    state.pendingImageName = '';
    if (ui.messageFile) {
      ui.messageFile.value = '';
    }
    updateImagePreview();
  }

  function handleImageSelection(event) {
    const files = event.target.files || [];
    if (!files.length) return;
    const file = files[0];
    if (!file.type.startsWith('image/')) {
      showStatus('Only image files are allowed.');
      event.target.value = '';
      return;
    }
    if (file.size > MAX_IMAGE_BYTES) {
      showStatus('Image too big. Keep it under 512 KB.');
      event.target.value = '';
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      state.pendingImage = reader.result;
      state.pendingImageName = file.name;
      updateImagePreview();
    };
    reader.onerror = () => {
      showStatus('Could not read that file.');
      event.target.value = '';
    };
    reader.readAsDataURL(file);
  }

  function togglePrivateFields(show) {
    if (!ui.codeLabel) return;
    if (show) {
      ui.codeLabel.classList.remove('hidden');
    } else {
      ui.codeLabel.classList.add('hidden');
    }
  }

  function persistMembership() {
    save(STORAGE.members, Array.from(membership));
  }

  function renderRooms() {
    renderRoomBucket(ui.publicRoomList, rooms.filter((room) => room.type === 'public'), true);
    renderRoomBucket(ui.privateRoomList, rooms.filter((room) => room.type === 'private' && membership.has(room.id)), false);
  }

  function renderRoomBucket(container, roomSet, autoJoin) {
    if (!container) return;
    container.innerHTML = '';
    if (!roomSet.length) {
      const li = document.createElement('li');
      li.className = 'muted tiny';
      li.textContent = autoJoin ? 'No public rooms available yet.' : 'You have not joined any private spaces.';
      container.appendChild(li);
      return;
    }

    roomSet.forEach((room) => {
      const clone = ui.roomTemplate.content.firstElementChild.cloneNode(true);
      const button = clone.querySelector('.room-btn');
      const nameEl = clone.querySelector('.room-name');
      const descEl = clone.querySelector('.room-desc');
      nameEl.textContent = room.name;
      descEl.textContent = room.description || (room.type === 'private' ? 'Private space' : 'Public room');
      if (state.activeRoomId === room.id) {
        button.classList.add('active');
      }
      button.addEventListener('click', () => {
        if (autoJoin && !membership.has(room.id)) {
          membership.add(room.id);
          persistMembership();
        }
        setActiveRoom(room.id);
      });
      container.appendChild(clone);
    });
  }

  function setActiveRoom(roomId) {
    state.activeRoomId = roomId;
    if (!roomId) {
      ui.roomTitle.textContent = 'Pick a room to start chatting';
      ui.roomMeta.textContent = 'No room selected.';
      ui.roomTypePill.textContent = 'â€”';
      ui.chatLog.innerHTML = '<div class="empty-chat"><p>Pick a room on the left to see the conversation.</p></div>';
      if (ui.sendButton) ui.sendButton.disabled = true;
      ui.leaveRoomBtn.disabled = true;
      ui.memberList.innerHTML = '';
      ui.inviteBlock.hidden = true;
      ui.activeRoom.dataset.room = '';
      clearPendingImage();
      renderRooms();
      return;
    }

    const room = roomMap.get(roomId);
    if (!room) return;
    if (!membership.has(roomId)) {
      membership.add(roomId);
      persistMembership();
      renderRooms();
    }
    ui.activeRoom.dataset.room = roomId;
    ui.roomTitle.textContent = room.name;
    ui.roomMeta.textContent = `${room.type === 'private' ? 'Private space' : 'Public lounge'} â€¢ Created ${formatRelativeTime(room.createdAt || Date.now())}`;
    ui.roomTypePill.textContent = room.type === 'private' ? 'Private' : 'Public';
    renderMessages(roomId);
    renderMembers(room);
    if (ui.sendButton) ui.sendButton.disabled = false;
    ui.leaveRoomBtn.disabled = room.type === 'public';
    if (room.type === 'private') {
      const code = room.inviteCode || '';
      ui.inviteValue.textContent = code;
      ui.inviteBlock.hidden = !code;
    } else {
      ui.inviteBlock.hidden = true;
    }
    renderRooms();
  }

  function renderMessages(roomId) {
    const list = messages[roomId] || [];
    const ul = document.createElement('ul');
    list.sort((a, b) => a.ts - b.ts);
    list.forEach((entry) => {
      const node = ui.messageTemplate.content.firstElementChild.cloneNode(true);
      node.querySelector('.author').textContent = entry.author;
      node.querySelector('time').textContent = formatTime(entry.ts);
      const textEl = node.querySelector('.text');
      if (entry.text) {
        textEl.textContent = entry.text;
        textEl.classList.remove('hidden');
      } else {
        textEl.textContent = '';
        textEl.classList.add('hidden');
      }
      const imageBlock = node.querySelector('.image-block');
      if (imageBlock) {
        if (entry.image) {
          imageBlock.classList.remove('hidden');
          const img = imageBlock.querySelector('img');
          if (img) {
            img.src = entry.image;
            img.alt = entry.imageName || 'Chat attachment';
          }
          const caption = imageBlock.querySelector('.caption');
          if (caption) {
            caption.textContent = entry.imageName || 'Image';
          }
        } else {
          imageBlock.classList.add('hidden');
        }
      }
      ul.appendChild(node);
    });
    ui.chatLog.innerHTML = '';
    ui.chatLog.appendChild(ul);
    ui.chatLog.scrollTop = ui.chatLog.scrollHeight;
  }

  function renderMembers(room) {
    if (!room) return;
    const list = ui.memberList;
    list.innerHTML = '';
    const names = new Set();
    names.add(profileName);
    if (Array.isArray(room.peers)) {
      room.peers.forEach((name) => names.add(name));
    }
    const membershipKey = `members:${room.id}`;
    const extra = load(membershipKey, []);
    extra.forEach((name) => names.add(name));

    names.forEach((name) => {
      const node = ui.memberTemplate.content.firstElementChild.cloneNode(true);
      node.querySelector('.name').textContent = name;
      list.appendChild(node);
    });
    if (list.children.length === 0) {
      const empty = document.createElement('li');
      empty.className = 'muted tiny';
      empty.textContent = 'Looks empty. Invite someone!';
      list.appendChild(empty);
    }
  }

  function handleCreateRoom(event) {
    event.preventDefault();
    const nameField = document.getElementById('newRoomName');
    const typeField = document.getElementById('newRoomType');
    const descField = document.getElementById('newRoomDesc');
    const codeField = document.getElementById('newRoomCode');
    const name = (nameField.value || '').trim();
    if (!name) return;
    const type = typeField.value === 'private' ? 'private' : 'public';
    const desc = (descField.value || '').trim();
    let code = (codeField.value || '').trim().toUpperCase();
    if (type === 'private' && !code) {
      code = generateCode();
    }
    const roomId = `room_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    const room = {
      id: roomId,
      name,
      type,
      description: desc,
      inviteCode: type === 'private' ? code : '',
      createdBy: profileName,
      createdAt: Date.now(),
      peers: type === 'public' ? [profileName] : []
    };
    rooms.push(room);
    roomMap.set(roomId, room);
    save(STORAGE.rooms, rooms);
    membership.add(roomId);
    persistMembership();
    messages[roomId] = [
      {
        id: `${roomId}-welcome`,
        author: profileName,
        text: desc ? `Room created â€” ${desc}` : 'New room created. Say hello!',
        ts: Date.now()
      }
    ];
    save(STORAGE.messages, messages);
    showStatus(`${room.name} ready to chat!`);
    ui.createRoomForm.reset();
    togglePrivateFields(false);
    renderRooms();
    setActiveRoom(roomId);
  }

  function handleJoinCode(event) {
    event.preventDefault();
    const input = document.getElementById('joinCode');
    const code = (input.value || '').trim().toUpperCase();
    if (!code) return;
    const room = rooms.find((item) => item.type === 'private' && item.inviteCode && item.inviteCode.toUpperCase() === code);
    if (!room) {
      showStatus('No private space matches that code.');
      return;
    }
    membership.add(room.id);
    persistMembership();
    const membershipKey = `members:${room.id}`;
    const existing = load(membershipKey, []);
    if (!existing.includes(profileName)) {
      existing.push(profileName);
      save(membershipKey, existing);
    }
    showStatus(`Joined ${room.name}!`);
    renderRooms();
    setActiveRoom(room.id);
    input.value = '';
  }

  function handleSendMessage(event) {
    event.preventDefault();
    if (!state.activeRoomId) return;
    const value = (ui.messageInput.value || '').trim();
    const hasImage = Boolean(state.pendingImage);
    if (!value && !hasImage) return;
    const roomMessages = messages[state.activeRoomId] || [];
    roomMessages.push({
      id: `msg_${state.activeRoomId}_${Date.now()}`,
      author: profileName,
      text: value,
      image: hasImage ? state.pendingImage : undefined,
      imageName: hasImage ? (state.pendingImageName || 'image') : undefined,
      ts: Date.now()
    });
    messages[state.activeRoomId] = roomMessages.slice(-200);
    save(STORAGE.messages, messages);
    ui.messageInput.value = '';
    clearPendingImage();
    renderMessages(state.activeRoomId);
  }

  function formatTime(ts) {
    const date = new Date(ts);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function formatRelativeTime(ts) {
    const delta = Date.now() - ts;
    if (delta < 60 * 1000) return 'just now';
    if (delta < 60 * 60 * 1000) {
      const minutes = Math.floor(delta / (60 * 1000));
      return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
    }
    if (delta < 24 * 60 * 60 * 1000) {
      const hours = Math.floor(delta / (60 * 60 * 1000));
      return `${hours} hour${hours === 1 ? '' : 's'} ago`;
    }
    const days = Math.floor(delta / (24 * 60 * 60 * 1000));
    return `${days} day${days === 1 ? '' : 's'} ago`;
  }

  function generateCode() {
    const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let result = '';
    for (let i = 0; i < 6; i += 1) {
      result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
    }
    return result;
  }

  renderRooms();
  if (membership.size) {
    const first = Array.from(membership)[0];
    setActiveRoom(first);
  }
})();
  </script>
  <script>
(function () {
  const STORAGE_KEY = 'carpai.conversation';
  const MAX_HISTORY = 30;

  const ui = {
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatInput: document.getElementById('chatInput'),
    typing: document.getElementById('typingIndicator'),
    promptButtons: document.querySelectorAll('[data-prompt]'),
    resetBtn: document.getElementById('resetChat'),
    suggestBtn: document.getElementById('suggestBtn')
  };

  const KNOWLEDGE = [
    {
      id: 'games',
      keywords: ['game', 'games', 'play', 'arcade', 'carpfish', 'snake', 'breakout', 'memory'],
      responses: [
        'Dive into <strong>CarpFish</strong> for retro fun: Snake, Breakout, Memory Match, and more live there.',
        'Want a challenge? Visit CarpFish from the top navigation â€” every game is playable in the browser.',
        'High scores await in CarpFish. Look for the â€œgamesâ€ button in the header to start playing.'
      ],
      link: 'carpfish.html'
    },
    {
      id: 'social',
      keywords: ['social', 'post', 'carpstream', 'upload', 'share', 'feed', 'comment', 'like'],
      responses: [
        'CarpStream lets you upload mp4, mov, webm, png, jpg, and gif files up to 5MB. Hit â€œnew postâ€ to begin.',
        'Ready to share something? Go to CarpStream and press â€œnew postâ€ â€” you can pick a file and add a caption.',
        'Looking for reactions and comments? CarpStream is the social hub. Try it from the navigation bar.'
      ],
      link: 'social.html'
    },
    {
      id: 'account',
      keywords: ['account', 'profile', 'settings', 'password', 'privacy', 'email', 'username'],
      responses: [
        'Manage your profile, email, and privacy switches in the <strong>Settings</strong> hub.',
        'Need to update details or switch themes? The Settings page has controls for privacy, appearance, and more.',
        'To change your password, open Settings, scroll to Security, and fill in the update form.'
      ],
      link: 'settings.html'
    },
    {
      id: 'fun',
      keywords: ['fact', 'fun', 'joke', 'fish', 'carp'],
      responses: [
        'Fun fact: Carp can remember feeding spots for months â€” maybe thatâ€™s why our games are so sticky.',
        'Why did the carp go viral? Because it always made a splash on CarpStream!',
        'Carp are natural problem solvers. Ask me anything and weâ€™ll tackle it together.'
      ]
    },
    {
      id: 'help',
      keywords: ['help', 'commands', 'options', 'what can you do', 'confused'],
      responses: [
        'I can point you to games, tracks for posting, account tools, or drop a Carp fact. Try â€œhow do I post?â€',
        'Need ideas? Ask about â€œgamesâ€, â€œpostingâ€, â€œsettingsâ€, or say â€œgive me a fun factâ€.'
      ]
    }
  ];

  const FALLBACKS = [
    'Iâ€™m not sure about that yet, but I can help with games, social posts, or account tools.',
    'That swims outside my pond. Try asking about games, posting, account settings, or for a fun fact.'
  ];

  const SUGGESTIONS = [
    'How do I reset my password?',
    'What formats can I upload to CarpStream?',
    'Show me where the CarpFish games are.',
    'Give me three ideas for a social post.',
    'How do I keep my account private?',
    'Tell me a fish joke.'
  ];

  function loadHistory() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : null;
    } catch (err) {
      console.warn('Failed to load Carp AI history', err);
      return null;
    }
  }

  function saveHistory(messages) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(messages.slice(-MAX_HISTORY)));
    } catch (err) {
      console.warn('Failed to save Carp AI history', err);
    }
  }

  function createMessageElement(message) {
    const item = document.createElement('li');
    item.className = `message ${message.role}`;
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.innerHTML = message.html;
    item.appendChild(bubble);
    const time = document.createElement('time');
    time.textContent = message.timestamp || 'just now';
    item.appendChild(time);
    return item;
  }

  function renderMessages(messages) {
    ui.chatLog.innerHTML = '';
    messages.forEach((message) => {
      ui.chatLog.appendChild(createMessageElement(message));
    });
    ui.chatLog.scrollTop = ui.chatLog.scrollHeight;
  }

  function normalise(text) {
    return text.toLowerCase().replace(/[^a-z0-9\s]/g, ' ');
  }

  function pick(list) {
    return list[Math.floor(Math.random() * list.length)];
  }

  function buildLinkHTML(text, link) {
    if (!link) return text;
    return `${text} <a href="${link}" class="chat-link">Open link</a>`;
  }

  function classifyMessage(message) {
    const cleaned = normalise(message);
    for (const topic of KNOWLEDGE) {
      if (topic.keywords.some((keyword) => cleaned.includes(keyword))) {
        return topic;
      }
    }
    return null;
  }

  function generateResponse(message, history) {
    const topic = classifyMessage(message);
    if (topic) {
      const text = pick(topic.responses);
      return buildLinkHTML(text, topic.link);
    }

    // leverage recent history to appear contextual
    const lastUser = history.slice().reverse().find((entry) => entry.role === 'user');
    if (lastUser && lastUser.raw && lastUser.raw !== message) {
      return `I'm still thinking about "${lastUser.raw}". Want to clarify what you need about games, social, or settings?`;
    }

    return pick(FALLBACKS);
  }

  function addMessage(messages, role, html, raw) {
    const entry = {
      role,
      html,
      raw: raw || html,
      timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
    };
    messages.push(entry);
    return entry;
  }

  function showTyping(show) {
    if (!ui.typing) return;
    ui.typing.classList.toggle('hidden', !show);
  }

  function handleSubmit(event) {
    event.preventDefault();
    const value = ui.chatInput.value.trim();
    if (!value) return;

    const history = loadHistory() || [];
    addMessage(history, 'user', escapeHTML(value), value);
    renderMessages(history);
    saveHistory(history);
    ui.chatInput.value = '';
    ui.chatInput.focus();

    showTyping(true);
    setTimeout(() => {
      const answer = generateResponse(value, history);
      addMessage(history, 'bot', answer);
      renderMessages(history);
      saveHistory(history);
      showTyping(false);
    }, 260 + Math.random() * 240);
  }

  function handlePrompt(event) {
    const prompt = event.currentTarget?.dataset?.prompt;
    if (!prompt) return;
    ui.chatInput.value = prompt;
    ui.chatInput.focus();
  }

  function handleReset() {
    localStorage.removeItem(STORAGE_KEY);
    const seed = createSeedConversation();
    saveHistory(seed);
    renderMessages(seed);
    ui.chatInput.focus();
  }

  function handleSuggest() {
    ui.chatInput.value = pick(SUGGESTIONS);
    ui.chatInput.focus();
  }

  function escapeHTML(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function createSeedConversation() {
    const seed = [
      addMessage([], 'bot', 'Hey there! Iâ€™m <strong>Carp AI</strong>. Ask me about games, posting to CarpStream, polishing your profile, or something fun.'),
      addMessage([], 'bot', 'Tip: tap one of the quick prompts on the left if you need inspiration.')
    ];
    return seed;
  }

  function init() {
    const history = loadHistory() || createSeedConversation();
    renderMessages(history);
    saveHistory(history);

    ui.chatForm.addEventListener('submit', handleSubmit);
    ui.promptButtons.forEach((button) => button.addEventListener('click', handlePrompt));
    if (ui.resetBtn) ui.resetBtn.addEventListener('click', handleReset);
    if (ui.suggestBtn) ui.suggestBtn.addEventListener('click', handleSuggest);
  }

  init();
})();
  </script>
</body>
</html>
